// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.zcash;

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the detils of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.ptr.ByReference
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    @JvmField var capacity: Int = 0
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : RustBuffer(), Structure.ByValue
    class ByReference : RustBuffer(), Structure.ByReference

    companion object {
        internal fun alloc(size: Int = 0) = rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_rustbuffer_alloc(size, status).also {
                if(it.data == null) {
                   throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
               }
            }
        }

        internal fun free(buf: RustBuffer.ByValue) = rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setInt(0, value.capacity)
        pointer.setInt(4, value.len)
        pointer.setPointer(8, value.data)
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): Int

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity.toLong()).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
@Structure.FieldOrder("code", "error_buf")
internal open class RustCallStatus : Structure() {
    @JvmField var code: Int = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    fun isSuccess(): Boolean {
        return code == 0
    }

    fun isError(): Boolean {
        return code == 1
    }

    fun isPanic(): Boolean {
        return code == 2
    }
}

class InternalException(message: String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: Exception> rustCallWithError(errorHandler: CallStatusErrorHandler<E>, callback: (RustCallStatus) -> U): U {
    var status = RustCallStatus();
    val return_value = callback(status)
    if (status.isSuccess()) {
        return return_value
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object NullCallStatusErrorHandler: CallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> rustCall(callback: (RustCallStatus) -> U): U {
    return rustCallWithError(NullCallStatusErrorHandler, callback);
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "uniffi_zcash"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface _UniFFILib : Library {
    companion object {
        internal val INSTANCE: _UniFFILib by lazy {
            loadIndirect<_UniFFILib>(componentName = "zcash")
            
        }
    }

    fun ffi_zcash_6e86_ZcashRecipientAddress_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashRecipientAddress_decode(`params`: RustBuffer.ByValue,`address`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashRecipientAddress_shielded(`addr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashRecipientAddress_transparent(`addr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashRecipientAddress_unified(`addr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashRecipientAddress_encode(`ptr`: Pointer,`params`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashUnifiedAddress_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashUnifiedAddress_new(`orchard`: RustBuffer.ByValue,`sapling`: RustBuffer.ByValue,`transparent`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedAddress_decode(`params`: RustBuffer.ByValue,`address`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedAddress_orchard(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashUnifiedAddress_sapling(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashUnifiedAddress_transparent(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashUnifiedAddress_encode(`ptr`: Pointer,`params`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashUnifiedFullViewingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashUnifiedFullViewingKey_new(`transparent`: RustBuffer.ByValue,`sapling`: RustBuffer.ByValue,`orchard`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedFullViewingKey_decode(`params`: RustBuffer.ByValue,`encoded`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedFullViewingKey_encode(`ptr`: Pointer,`params`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashUnifiedFullViewingKey_transparent(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashUnifiedFullViewingKey_sapling(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashUnifiedFullViewingKey_orchard(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashUnifiedFullViewingKey_address(`ptr`: Pointer,`j`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashUnifiedFullViewingKey_find_address(`ptr`: Pointer,`j`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashUnifiedFullViewingKey_default_address(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashUnifiedSpendingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashUnifiedSpendingKey_from_seed(`params`: RustBuffer.ByValue,`seed`: RustBuffer.ByValue,`accountId`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedSpendingKey_from_bytes(`era`: RustBuffer.ByValue,`encoded`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedSpendingKey_to_unified_full_viewing_key(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedSpendingKey_transparent(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedSpendingKey_sapling(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedSpendingKey_orchard(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashUnifiedSpendingKey_to_bytes(`ptr`: Pointer,`era`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardNote_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardNote_from_parts(`recipient`: Pointer,`value`: Pointer,`rho`: Pointer,`rseed`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardNote_recipient(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardNote_value(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardNote_commitment(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashOrchardNullifier_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardNullifier_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardNullifier_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardRandomSeed_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardRandomSeed_from_bytes(`data`: RustBuffer.ByValue,`rho`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardRandomSeed_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardNoteCommitment_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardNoteCommitment_to_extracted_note_commitment(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashExtractedNoteCommitment_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashExtractedNoteCommitment_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtractedNoteCommitment_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardAddress_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardAddress_from_raw_address_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardAddress_diversifier(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardAddress_to_raw_address_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashVerifyingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashVerifyingKey_new(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashProvingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashProvingKey_new(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashOrchardBundle_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardBundle_actions(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardBundle_flags(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardBundle_value_balance(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardBundle_anchor(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardBundle_verify_proof(`ptr`: Pointer,`key`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardBundle_decrypt_output_with_key(`ptr`: Pointer,`actionIdx`: Long,`ivk`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardBundle_decrypt_output_with_keys(`ptr`: Pointer,`ivks`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardBundle_recover_output_with_ovk(`ptr`: Pointer,`actionIdx`: Long,`ovk`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardBundle_recover_outputs_with_ovks(`ptr`: Pointer,`ovks`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardFlags_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardFlags_from_parts(`spendsEnabled`: Byte,`outputsEnabled`: Byte,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardFlags_from_byte(`v`: Byte,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardFlags_spends_enabled(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun zcash_6e86_ZcashOrchardFlags_outputs_enabled(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun zcash_6e86_ZcashOrchardFlags_to_byte(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun ffi_zcash_6e86_ZcashOrchardNoteValue_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardNoteValue_from_raw(`value`: Long,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardNoteValue_value(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Long

    fun ffi_zcash_6e86_ZcashOrchardValueCommitment_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardValueCommitment_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardAction_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardAction_nullifier(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardAction_cmx(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardAction_encrypted_note(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardAction_cv_net(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashOrchardFullViewingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardFullViewingKey_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardFullViewingKey_address_at(`ptr`: Pointer,`j`: Pointer,`scope`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardFullViewingKey_address(`ptr`: Pointer,`d`: Pointer,`scope`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardFullViewingKey_scope_for_address(`ptr`: Pointer,`address`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardFullViewingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardFullViewingKey_to_ivk(`ptr`: Pointer,`scope`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardFullViewingKey_to_ovk(`ptr`: Pointer,`scope`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashOrchardSpendingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardSpendingKey_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardSpendingKey_from_zip32_seed(`seed`: RustBuffer.ByValue,`coinType`: Int,`account`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardSpendingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardSpendingKey_to_fvk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashAnchor_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashAnchor_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAnchor_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardIncomingViewingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardIncomingViewingKey_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardIncomingViewingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardIncomingViewingKey_diversifier_index(`ptr`: Pointer,`addr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashOrchardIncomingViewingKey_address_at(`ptr`: Pointer,`j`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardIncomingViewingKey_address(`ptr`: Pointer,`diversifier`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashOrchardDiversifier_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardDiversifier_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardDiversifier_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardOutgoingViewingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardOutgoingViewingKey_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardOutgoingViewingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardMerklePath_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardMerklePath_from_parts(`position`: Int,`authPath`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardMerklePath_root(`ptr`: Pointer,`cmx`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashOrchardMerkleHash_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardMerkleHash_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardMerkleHash_from_cmx(`cmx`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardMerkleHash_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardDiversifierIndex_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardDiversifierIndex_from_bytes(`b`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardDiversifierIndex_from_u32(`i`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardDiversifierIndex_from_u64(`i`: Long,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardDiversifierIndex_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashExtendedPrivKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashExtendedPrivKey_random(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedPrivKey_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedPrivKey_random_with_seed_size(`seedSize`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedPrivKey_with_seed(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedPrivKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExtendedPrivKey_derive_private_key(`ptr`: Pointer,`keyIndex`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashKeyIndex_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashKeyIndex_from_u32(`i`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashKeyIndex_hardened_from_normalize_index(`i`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashKeyIndex_from_index(`i`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashKeyIndex_raw_index(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Int

    fun zcash_6e86_ZcashKeyIndex_normalize_index(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Int

    fun zcash_6e86_ZcashKeyIndex_is_valid(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun ffi_zcash_6e86_ZcashZip317FeeRule_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashZip317FeeRule_standard(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashZip317FeeRule_non_standard(`marginalFee`: Pointer,`graceActions`: Long,`p2pkhStandardInputSize`: Long,`p2pkhStandardOutputSize`: Long,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashZip317FeeRule_marginal_fee(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashFixedFeeRule_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashFixedFeeRule_non_standard(`fixedFee`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashFixedFeeRule_standard(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashFixedFeeRule_fixed_fee(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashTransparentBundle_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTransparentBundle_is_coinbase(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun zcash_6e86_ZcashTransparentBundle_vin(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashTransparentBundle_vout(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashTxOut_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTxOut_new(`value`: Pointer,`scriptPubkey`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTxOut_value(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTxOut_script_pubkey(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTxOut_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashTxOut_recipient_address(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashTxIn_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTxIn_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashTransactionBuilder_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTransactionBuilder_new(`parameters`: RustBuffer.ByValue,`blockHeight`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTransactionBuilder_add_sapling_spend(`ptr`: Pointer,`extsk`: Pointer,`diversifier`: Pointer,`note`: Pointer,`merklePath`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTransactionBuilder_add_sapling_output(`ptr`: Pointer,`ovk`: RustBuffer.ByValue,`to`: Pointer,`value`: Pointer,`memo`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTransactionBuilder_add_transparent_input(`ptr`: Pointer,`sk`: Pointer,`utxo`: Pointer,`coin`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTransactionBuilder_add_transparent_output(`ptr`: Pointer,`to`: Pointer,`value`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTransactionBuilder_build(`ptr`: Pointer,`prover`: Pointer,`feeRule`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashTransaction_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTransaction_from_bytes(`data`: RustBuffer.ByValue,`consensusBranchId`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTransaction_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashTransaction_txid(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTransaction_version(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTransaction_consensus_branch_id(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashTransaction_lock_time(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Int

    fun zcash_6e86_ZcashTransaction_expiry_height(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTransaction_transparent_bundle(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashTransaction_sapling_bundle(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashTransaction_orchard_bundle(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashTxId_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTxId_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTxId_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOrchardTransactionBuilder_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardTransactionBuilder_new(`parameters`: RustBuffer.ByValue,`targetHeight`: Pointer,`expiryHeight`: Pointer,`anchor`: Pointer,`flags`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOrchardTransactionBuilder_add_spend(`ptr`: Pointer,`fvk`: Pointer,`note`: Pointer,`merklePath`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardTransactionBuilder_add_recipient(`ptr`: Pointer,`ovk`: RustBuffer.ByValue,`recipient`: Pointer,`value`: Pointer,`memo`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOrchardTransactionBuilder_build(`ptr`: Pointer,`keys`: RustBuffer.ByValue,`sighash`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashTxVersion_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTxVersion_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTxVersion_suggested_for_branch(`consensusBranchId`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTxVersion_selection(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashTxVersion_header(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Int

    fun zcash_6e86_ZcashTxVersion_version_group_id(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Int

    fun zcash_6e86_ZcashTxVersion_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashTxVersion_has_sprout(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun zcash_6e86_ZcashTxVersion_has_overwinter(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun zcash_6e86_ZcashTxVersion_has_sapling(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun zcash_6e86_ZcashTxVersion_has_orchard(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun ffi_zcash_6e86_ZcashOutPoint_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOutPoint_new(`hash`: RustBuffer.ByValue,`n`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashAmount_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashAmount_new(`amount`: Long,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAmount_zero(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAmount_value(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Long

    fun ffi_zcash_6e86_ZcashSaplingSpendDescription_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingSpendDescription_cv(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashSaplingSpendDescription_anchor(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashSaplingSpendDescription_nullifier(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashSaplingSpendDescription_rk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashSaplingBundle_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingBundle_shielded_spends(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashSaplingBundle_shielded_outputs(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashSaplingBundle_value_balance(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashSaplingOutputDescription_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingOutputDescription_cv(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashSaplingOutputDescription_cmu(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashSaplingMetadata_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingMetadata_new(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashSaplingMetadata_spend_index(`ptr`: Pointer,`n`: Long,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashSaplingMetadata_output_index(`ptr`: Pointer,`n`: Long,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashBlockHeight_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashBlockHeight_new(`v`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashBlockHeight_value(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Int

    fun ffi_zcash_6e86_ZcashCommitmentTree_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashCommitmentTree_empty(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashCommitmentTree_append(`ptr`: Pointer,`node`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun ffi_zcash_6e86_ZcashSaplingMerklePath_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingMerklePath_auth_path(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashSaplingMerklePath_position(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Long

    fun ffi_zcash_6e86_ZcashIncrementalWitness_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashIncrementalWitness_from_tree(`tree`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashIncrementalWitness_append(`ptr`: Pointer,`node`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashIncrementalWitness_path(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashTransparentAddress_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashTransparentAddress_from_public_key(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTransparentAddress_from_script(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTransparentAddress_decode(`params`: RustBuffer.ByValue,`input`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTransparentAddress_encode(`ptr`: Pointer,`params`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashTransparentAddress_is_public_key(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun zcash_6e86_ZcashTransparentAddress_is_script(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Byte

    fun zcash_6e86_ZcashTransparentAddress_script(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashTransparentAddress_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashExternalIvk_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashExternalIvk_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExternalIvk_derive_address(`ptr`: Pointer,`childIndex`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExternalIvk_default_address(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExternalIvk_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashInternalIvk_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashInternalIvk_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashInternalIvk_default_address(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashInternalIvk_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashExternalOvk_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashExternalOvk_as_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashInternalOvk_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashInternalOvk_as_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashAccountPubKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashAccountPubKey_new(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPubKey_derive_external_ivk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPubKey_derive_internal_ivk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPubKey_ovks_for_shielding(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashAccountPubKey_internal_ovk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPubKey_external_ovk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPubKey_serialize(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashAccountPrivKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashAccountPrivKey_from_seed(`params`: RustBuffer.ByValue,`seed`: RustBuffer.ByValue,`accountId`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPrivKey_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPrivKey_from_extended_privkey(`key`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPrivKey_to_account_pubkey(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPrivKey_derive_external_secret_key(`ptr`: Pointer,`childIndex`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPrivKey_derive_internal_secret_key(`ptr`: Pointer,`childIndex`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashAccountPrivKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashScript_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashScript_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashScript_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashSaplingValueCommitment_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingValueCommitment_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashSaplingNote_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingNote_from_parts(`recipient`: Pointer,`value`: Pointer,`rseed`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashSaplingNote_value(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashSaplingNote_cmu(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashSaplingNoteValue_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingNoteValue_from_raw(`data`: Long,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashSaplingNoteValue_inner(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Long

    fun ffi_zcash_6e86_ZcashSaplingNullifier_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingNullifier_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashSaplingExtractedNoteCommitment_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingExtractedNoteCommitment_new(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashSaplingExtractedNoteCommitment_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashPaymentAddress_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashPaymentAddress_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashPaymentAddress_decode(`params`: RustBuffer.ByValue,`input`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashPaymentAddress_encode(`ptr`: Pointer,`params`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashPaymentAddress_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashPaymentAddress_diversifier(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashPaymentAddress_pk_d(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashPaymentAddress_create_note(`ptr`: Pointer,`value`: Long,`rseed`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashSaplingIvk_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingIvk_to_payment_address(`ptr`: Pointer,`diversifier`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashSaplingIvk_to_repr(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashDiversifier_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashDiversifier_new(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashDiversifier_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashFullViewingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashFullViewingKey_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashFullViewingKey_from_expanded_spending_key(`expsk`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashFullViewingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashFullViewingKey_vk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashFullViewingKey_ovk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashNullifierDerivingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashNullifierDerivingKey_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashNullifierDerivingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashOutgoingViewingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashOutgoingViewingKey_from_bytes(`b`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashOutgoingViewingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashExpandedSpendingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashExpandedSpendingKey_from_spending_key(`sk`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExpandedSpendingKey_from_bytes(`b`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExpandedSpendingKey_proof_generation_key(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExpandedSpendingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashProofGenerationKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashProofGenerationKey_to_viewing_key(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashDiversifiableFullViewingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_fvk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_to_nk(`ptr`: Pointer,`scope`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_to_ivk(`ptr`: Pointer,`scope`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_to_ovk(`ptr`: Pointer,`scope`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_address(`ptr`: Pointer,`j`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_find_address(`ptr`: Pointer,`j`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_default_address(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_diversified_address(`ptr`: Pointer,`diversifier`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_change_address(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_diversified_change_address(`ptr`: Pointer,`diversifier`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashDiversifiableFullViewingKey_decrypt_diversifier(`ptr`: Pointer,`addr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashSaplingDiversifiedTransmissionKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun ffi_zcash_6e86_ZcashViewingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashViewingKey_ivk(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashViewingKey_to_payment_address(`ptr`: Pointer,`diversifier`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashExtendedFullViewingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashExtendedFullViewingKey_from_bytes(`bytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedFullViewingKey_decode(`params`: RustBuffer.ByValue,`input`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedFullViewingKey_encode(`ptr`: Pointer,`params`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExtendedFullViewingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExtendedFullViewingKey_address(`ptr`: Pointer,`j`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExtendedFullViewingKey_derive_child(`ptr`: Pointer,`i`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedFullViewingKey_find_address(`ptr`: Pointer,`j`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExtendedFullViewingKey_default_address(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExtendedFullViewingKey_derive_internal(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashSaplingPublicKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingPublicKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashSaplingNode_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashSaplingNode_from_cmu(`cmu`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashExtendedSpendingKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashExtendedSpendingKey_master(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedSpendingKey_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedSpendingKey_from_path(`master`: Pointer,`path`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedSpendingKey_decode(`params`: RustBuffer.ByValue,`input`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedSpendingKey_encode(`ptr`: Pointer,`params`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExtendedSpendingKey_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExtendedSpendingKey_derive_child(`ptr`: Pointer,`index`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedSpendingKey_default_address(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_ZcashExtendedSpendingKey_derive_internal(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_ZcashDiversifierIndex_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashDiversifierIndex_new(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashDiversifierIndex_from_u32(`i`: Int,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashDiversifierIndex_from_u64(`i`: Long,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashDiversifierIndex_increment(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashDiversifierIndex_to_u32(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Int

    fun zcash_6e86_ZcashDiversifierIndex_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashMemoBytes_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashMemoBytes_new(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashMemoBytes_empty(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashMemoBytes_data(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashLocalTxProver_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashLocalTxProver_new(`spendPath`: RustBuffer.ByValue,`outputPath`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashLocalTxProver_from_bytes(`spendParamBytes`: RustBuffer.ByValue,`outputParamBytes`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashLocalTxProver_with_default_location(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun ffi_zcash_6e86_SecpSecretKey_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_SecpSecretKey_new(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_SecpSecretKey_serialize_secret(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_ZcashJubjubFr_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_ZcashJubjubFr_from_bytes(`data`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_ZcashJubjubFr_to_bytes(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_TestSupport_object_free(`ptr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun zcash_6e86_TestSupport_from_csv_file(
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_TestSupport_get_as_u8_array(`ptr`: Pointer,`key`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_TestSupport_get_as_u32_array(`ptr`: Pointer,`key`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_TestSupport_get_as_u64_array(`ptr`: Pointer,`key`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_TestSupport_get_as_u32(`ptr`: Pointer,`key`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Int

    fun zcash_6e86_TestSupport_get_as_u64(`ptr`: Pointer,`key`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Long

    fun zcash_6e86_TestSupport_get_as_string(`ptr`: Pointer,`key`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_decode_extended_full_viewing_key(`hrp`: RustBuffer.ByValue,`s`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_decode_extended_spending_key(`hrp`: RustBuffer.ByValue,`s`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_decode_payment_address(`hrp`: RustBuffer.ByValue,`s`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_decode_transparent_address(`pubkeyVersion`: RustBuffer.ByValue,`scriptVersion`: RustBuffer.ByValue,`s`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Pointer

    fun zcash_6e86_encode_extended_full_viewing_key(`hrp`: RustBuffer.ByValue,`extfvk`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_encode_extended_spending_key(`hrp`: RustBuffer.ByValue,`extsk`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_encode_payment_address(`hrp`: RustBuffer.ByValue,`addr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_encode_payment_address_p(`params`: RustBuffer.ByValue,`addr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_encode_transparent_address(`pubkeyVersion`: RustBuffer.ByValue,`scriptVersion`: RustBuffer.ByValue,`addr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun zcash_6e86_encode_transparent_address_p(`params`: RustBuffer.ByValue,`addr`: Pointer,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_rustbuffer_alloc(`size`: Int,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    fun ffi_zcash_6e86_rustbuffer_free(`buf`: RustBuffer.ByValue,
    _uniffi_out_err: RustCallStatus
    ): Unit

    fun ffi_zcash_6e86_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Int,
    _uniffi_out_err: RustCallStatus
    ): RustBuffer.ByValue

    
}

// Public interface members begin here.


public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

public object FfiConverterLong: FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len)
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteArr = value.toByteArray(Charsets.UTF_8)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteArr.size)
        rbuf.asByteBuffer()!!.put(byteArr)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    override fun allocationSize(value: String): Int {
        val sizeForLength = 4
        val sizeForString = value.length * 3
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteArr = value.toByteArray(Charsets.UTF_8)
        buf.putInt(byteArr.size)
        buf.put(byteArr)
    }
}


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

// The base class for all UniFFI Object types.
//
// This class provides core operations for working with the Rust `Arc<T>` pointer to
// the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// the Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each `FFIObject` instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an `FFIObject` is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an `FFIObject` instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so will
//     leak the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each `FFIObject` an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// In the future we may be able to replace some of this with automatic finalization logic, such as using
// the new "Cleaner" functionaility in Java 9. The above scheme has been designed to work even if `destroy` is
// invoked by garbage-collection machinery rather than by calling code (which by the way, it's apparently also
// possible for the JVM to finalize an object while there is an in-flight call to one of its methods [1],
// so there would still be some complexity here).
//
// Sigh...all of this for want of a robust finalization mechanism.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//
abstract class FFIObject(
    protected val pointer: Pointer
): Disposable, AutoCloseable {

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    open protected fun freeRustArcPtr() {
        // To be overridden in subclasses.
    }

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                this.freeRustArcPtr()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (! this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.pointer)
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                this.freeRustArcPtr()
            }
        }
    }
}

public interface SecpSecretKeyInterface {
    

    fun `serializeSecret`(): List<UByte>
    
}


class SecpSecretKey(
    pointer: Pointer
) : FFIObject(pointer), SecpSecretKeyInterface {

    constructor(`data`: List<UByte>) :
        this(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_SecpSecretKey_new(FfiConverterSequenceUByte.lower(`data`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_SecpSecretKey_object_free(this.pointer, status)
        }
    }

    override fun `serializeSecret`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_SecpSecretKey_serialize_secret(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeSecpSecretKey: FfiConverter<SecpSecretKey, Pointer> {
    override fun lower(value: SecpSecretKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): SecpSecretKey {
        return SecpSecretKey(value)
    }

    override fun read(buf: ByteBuffer): SecpSecretKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SecpSecretKey) = 8

    override fun write(value: SecpSecretKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface TestSupportInterface {
    

    fun `getAsU8Array`(`key`: String): List<UByte>
    

    fun `getAsU32Array`(`key`: String): List<UInt>
    

    fun `getAsU64Array`(`key`: String): List<ULong>
    

    fun `getAsU32`(`key`: String): UInt
    

    fun `getAsU64`(`key`: String): ULong
    

    fun `getAsString`(`key`: String): String
    
}


class TestSupport(
    pointer: Pointer
) : FFIObject(pointer), TestSupportInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_TestSupport_object_free(this.pointer, status)
        }
    }

    override fun `getAsU8Array`(`key`: String): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_TestSupport_get_as_u8_array(it, FfiConverterString.lower(`key`),  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `getAsU32Array`(`key`: String): List<UInt> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_TestSupport_get_as_u32_array(it, FfiConverterString.lower(`key`),  _status)
}
        }.let {
            FfiConverterSequenceUInt.lift(it)
        }
    override fun `getAsU64Array`(`key`: String): List<ULong> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_TestSupport_get_as_u64_array(it, FfiConverterString.lower(`key`),  _status)
}
        }.let {
            FfiConverterSequenceULong.lift(it)
        }
    override fun `getAsU32`(`key`: String): UInt =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_TestSupport_get_as_u32(it, FfiConverterString.lower(`key`),  _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `getAsU64`(`key`: String): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_TestSupport_get_as_u64(it, FfiConverterString.lower(`key`),  _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    override fun `getAsString`(`key`: String): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_TestSupport_get_as_string(it, FfiConverterString.lower(`key`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    

    companion object {
        

        fun `fromCsvFile`(): TestSupport =
            TestSupport(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_TestSupport_from_csv_file( _status)
})
        
    }
    
}

public object FfiConverterTypeTestSupport: FfiConverter<TestSupport, Pointer> {
    override fun lower(value: TestSupport): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TestSupport {
        return TestSupport(value)
    }

    override fun read(buf: ByteBuffer): TestSupport {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TestSupport) = 8

    override fun write(value: TestSupport, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashAccountPrivKeyInterface {
    

    fun `toAccountPubkey`(): ZcashAccountPubKey
    

    /**
     * Derives the BIP-44 private spending key for the external (incoming payment) child path 
     * `m/44'/<coin_type>'/<account>'/0/<child_index>`. 
     */
    @Throws(ZcashException::class)
    fun `deriveExternalSecretKey`(`childIndex`: UInt): SecpSecretKey
    

    /**
     * Derives the BIP-44 private spending key for the internal (change) child path 
     * `m/44'/<coin_type>'/<account>'/1/<child_index>`. 
     */
    @Throws(ZcashException::class)
    fun `deriveInternalSecretKey`(`childIndex`: UInt): SecpSecretKey
    

    /**
     * Returns the `AccountPrivKey` serialized using the encoding for a 
     * [BIP 32](https://en.bitcoin.it/wiki/BIP_0032) ExtendedPrivKey 
     */
    fun `toBytes`(): List<UByte>
    
}


/**
 * A type representing a BIP-44 private key at the account path level 
 * `m/44'/<coin_type>'/<account>' 
 */
class ZcashAccountPrivKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashAccountPrivKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashAccountPrivKey_object_free(this.pointer, status)
        }
    }

    override fun `toAccountPubkey`(): ZcashAccountPubKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPrivKey_to_account_pubkey(it,  _status)
}
        }.let {
            FfiConverterTypeZcashAccountPubKey.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `deriveExternalSecretKey`(`childIndex`: UInt): SecpSecretKey =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPrivKey_derive_external_secret_key(it, FfiConverterUInt.lower(`childIndex`),  _status)
}
        }.let {
            FfiConverterTypeSecpSecretKey.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `deriveInternalSecretKey`(`childIndex`: UInt): SecpSecretKey =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPrivKey_derive_internal_secret_key(it, FfiConverterUInt.lower(`childIndex`),  _status)
}
        }.let {
            FfiConverterTypeSecpSecretKey.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPrivKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

    /**
     * Performs derivation of the extended private key for the BIP-44 path: 
     * `m/44'/<coin_type>'/<account>'`. 
     *  
     * This produces the root of the derivation tree for transparent 
     * viewing keys and addresses for the for the provided account. 
     */
        fun `fromSeed`(`params`: ZcashConsensusParameters, `seed`: List<UByte>, `accountId`: ZcashAccountId): ZcashAccountPrivKey =
            ZcashAccountPrivKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPrivKey_from_seed(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterSequenceUByte.lower(`seed`), FfiConverterTypeZcashAccountId.lower(`accountId`), _status)
})
        

    /**
     * Decodes the `AccountPrivKey` from the encoding specified for a 
     * [BIP 32](https://en.bitcoin.it/wiki/BIP_0032) ExtendedPrivKey 
     */
        fun `fromBytes`(`data`: List<UByte>): ZcashAccountPrivKey =
            ZcashAccountPrivKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPrivKey_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        

        fun `fromExtendedPrivkey`(`key`: ZcashExtendedPrivKey): ZcashAccountPrivKey =
            ZcashAccountPrivKey(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPrivKey_from_extended_privkey(FfiConverterTypeZcashExtendedPrivKey.lower(`key`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashAccountPrivKey: FfiConverter<ZcashAccountPrivKey, Pointer> {
    override fun lower(value: ZcashAccountPrivKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashAccountPrivKey {
        return ZcashAccountPrivKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashAccountPrivKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashAccountPrivKey) = 8

    override fun write(value: ZcashAccountPrivKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashAccountPubKeyInterface {
    

    /**
     * Derives the BIP-44 public key at the external "change level" path 
     * `m/44'/<coin_type>'/<account>'/0`. 
     */
    @Throws(ZcashException::class)
    fun `deriveExternalIvk`(): ZcashExternalIvk
    

    /**
     * Derives the BIP-44 public key at the internal "change level" path 
     * `m/44'/<coin_type>'/<account>'/1`. 
     */
    @Throws(ZcashException::class)
    fun `deriveInternalIvk`(): ZcashInternalIvk
    

    /**
     * Derives the internal ovk and external ovk corresponding to this 
     * transparent fvk. As specified in [ZIP 316][transparent-ovk]. 
     *  
     * [transparent-ovk]: https://zips.z.cash/zip-0316#deriving-internal-keys 
     */
    fun `ovksForShielding`(): ZcashInternalOvkExternalOvk
    

    /**
     * Derives the internal ovk corresponding to this transparent fvk. 
     */
    fun `internalOvk`(): ZcashInternalOvk
    

    /**
     * Derives the external ovk corresponding to this transparent fvk. 
     */
    fun `externalOvk`(): ZcashExternalOvk
    

    fun `serialize`(): List<UByte>
    
}


/**
 * A type representing a BIP-44 public key at the account path level 
 * `m/44'/<coin_type>'/<account>'`. 
 *  
 * This provides the necessary derivation capability for the transparent component of a unified 
 * full viewing key. 
 */
class ZcashAccountPubKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashAccountPubKeyInterface {

    constructor(`data`: List<UByte>) :
        this(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPubKey_new(FfiConverterSequenceUByte.lower(`data`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashAccountPubKey_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `deriveExternalIvk`(): ZcashExternalIvk =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPubKey_derive_external_ivk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashExternalIvk.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `deriveInternalIvk`(): ZcashInternalIvk =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPubKey_derive_internal_ivk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashInternalIvk.lift(it)
        }
    override fun `ovksForShielding`(): ZcashInternalOvkExternalOvk =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPubKey_ovks_for_shielding(it,  _status)
}
        }.let {
            FfiConverterTypeZcashInternalOvkExternalOvk.lift(it)
        }
    override fun `internalOvk`(): ZcashInternalOvk =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPubKey_internal_ovk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashInternalOvk.lift(it)
        }
    override fun `externalOvk`(): ZcashExternalOvk =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPubKey_external_ovk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashExternalOvk.lift(it)
        }
    override fun `serialize`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAccountPubKey_serialize(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashAccountPubKey: FfiConverter<ZcashAccountPubKey, Pointer> {
    override fun lower(value: ZcashAccountPubKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashAccountPubKey {
        return ZcashAccountPubKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashAccountPubKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashAccountPubKey) = 8

    override fun write(value: ZcashAccountPubKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashAmountInterface {
    

    /**
     * Returns the value of the amount as i64. 
     */
    fun `value`(): Long
    
}


/**
 * A type-safe representation of some quantity of Zcash. 
 *  
 * An Amount can only be constructed from an integer that is within the valid monetary 
 * range of `{-MAX_MONEY..MAX_MONEY}` (where `MAX_MONEY` = 21,000,000 × 10⁸ zatoshis). 
 * However, this range is not preserved as an invariant internally; it is possible to 
 * add two valid Amounts together to obtain an invalid Amount. It is the user's 
 * responsibility to handle the result of serializing potentially-invalid Amounts. In 
 * particular, a [`Transaction`] containing serialized invalid Amounts will be rejected 
 * by the network consensus rules. 
 *  
 * [`Transaction`]: crate::transaction::Transaction 
 */
class ZcashAmount(
    pointer: Pointer
) : FFIObject(pointer), ZcashAmountInterface {

    /**
     * Creates an Amount from an i64. 
     *  
     * Returns an error if the amount is outside the range `{-MAX_MONEY..MAX_MONEY}`. 
     */
    constructor(`amount`: Long) :
        this(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAmount_new(FfiConverterLong.lower(`amount`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashAmount_object_free(this.pointer, status)
        }
    }

    override fun `value`(): Long =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAmount_value(it,  _status)
}
        }.let {
            FfiConverterLong.lift(it)
        }
    

    companion object {
        

    /**
     * Returns a zero-valued Amount. 
     */
        fun `zero`(): ZcashAmount =
            ZcashAmount(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAmount_zero( _status)
})
        
    }
    
}

public object FfiConverterTypeZcashAmount: FfiConverter<ZcashAmount, Pointer> {
    override fun lower(value: ZcashAmount): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashAmount {
        return ZcashAmount(value)
    }

    override fun read(buf: ByteBuffer): ZcashAmount {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashAmount) = 8

    override fun write(value: ZcashAmount, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashAnchorInterface {
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashAnchor(
    pointer: Pointer
) : FFIObject(pointer), ZcashAnchorInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashAnchor_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAnchor_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`bytes`: List<UByte>): ZcashAnchor =
            ZcashAnchor(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashAnchor_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashAnchor: FfiConverter<ZcashAnchor, Pointer> {
    override fun lower(value: ZcashAnchor): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashAnchor {
        return ZcashAnchor(value)
    }

    override fun read(buf: ByteBuffer): ZcashAnchor {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashAnchor) = 8

    override fun write(value: ZcashAnchor, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashBlockHeightInterface {
    

    fun `value`(): UInt
    
}


class ZcashBlockHeight(
    pointer: Pointer
) : FFIObject(pointer), ZcashBlockHeightInterface {

    constructor(`v`: UInt) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashBlockHeight_new(FfiConverterUInt.lower(`v`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashBlockHeight_object_free(this.pointer, status)
        }
    }

    override fun `value`(): UInt =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashBlockHeight_value(it,  _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashBlockHeight: FfiConverter<ZcashBlockHeight, Pointer> {
    override fun lower(value: ZcashBlockHeight): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashBlockHeight {
        return ZcashBlockHeight(value)
    }

    override fun read(buf: ByteBuffer): ZcashBlockHeight {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashBlockHeight) = 8

    override fun write(value: ZcashBlockHeight, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashCommitmentTreeInterface {
    

    @Throws(ZcashException::class)
    fun `append`(`node`: ZcashSaplingNode)
    
}


class ZcashCommitmentTree(
    pointer: Pointer
) : FFIObject(pointer), ZcashCommitmentTreeInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashCommitmentTree_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `append`(`node`: ZcashSaplingNode) =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashCommitmentTree_append(it, FfiConverterTypeZcashSaplingNode.lower(`node`),  _status)
}
        }
    
    

    companion object {
        

        fun `empty`(): ZcashCommitmentTree =
            ZcashCommitmentTree(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashCommitmentTree_empty( _status)
})
        
    }
    
}

public object FfiConverterTypeZcashCommitmentTree: FfiConverter<ZcashCommitmentTree, Pointer> {
    override fun lower(value: ZcashCommitmentTree): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashCommitmentTree {
        return ZcashCommitmentTree(value)
    }

    override fun read(buf: ByteBuffer): ZcashCommitmentTree {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashCommitmentTree) = 8

    override fun write(value: ZcashCommitmentTree, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashDiversifiableFullViewingKeyInterface {
    

    /**
     * Returns the raw encoding of this `DiversifiableFullViewingKey`. 
     */
    fun `toBytes`(): List<UByte>
    

    /**
     * Exposes the external [`FullViewingKey`] component of this diversifiable full viewing key. 
     */
    fun `fvk`(): ZcashFullViewingKey
    

    /**
     * Derives a nullifier-deriving key for the provided scope. 
     *  
     * This API is provided so that nullifiers for change notes can be correctly computed. 
     */
    fun `toNk`(`scope`: ZcashScope): ZcashNullifierDerivingKey
    

    /**
     * Derives an incoming viewing key corresponding to this full viewing key. 
     */
    fun `toIvk`(`scope`: ZcashScope): ZcashSaplingIvk
    

    /**
     * Derives an outgoing viewing key corresponding to this full viewing key. 
     */
    fun `toOvk`(`scope`: ZcashScope): ZcashOutgoingViewingKey
    

    /**
     * Attempts to produce a valid payment address for the given diversifier index. 
     *  
     * Returns `None` if the diversifier index does not produce a valid diversifier for 
     * this `DiversifiableFullViewingKey`. 
     */
    fun `address`(`j`: ZcashDiversifierIndex): ZcashPaymentAddress?
    

    /**
     * Finds the next valid payment address starting from the given diversifier index. 
     *  
     * This searches the diversifier space starting at `j` and incrementing, to find an 
     * index which will produce a valid diversifier (a 50% probability for each index). 
     *  
     * Returns the index at which the valid diversifier was found along with the payment 
     * address constructed using that diversifier, or `None` if the maximum index was 
     * reached and no valid diversifier was found. 
     */
    fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashDiversifierIndexAndPaymentAddress?
    

    /**
     * Returns the payment address corresponding to the smallest valid diversifier index, 
     * along with that index. 
     */
    fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress
    

    /**
     * Returns the payment address corresponding to the specified diversifier, if any. 
     *  
     * In general, it is preferable to use `find_address` instead, but this method is 
     * useful in some cases for matching keys to existing payment addresses. 
     */
    fun `diversifiedAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress?
    

    /**
     * Returns the internal address corresponding to the smallest valid diversifier index, 
     * along with that index. 
     *  
     * This address **MUST NOT** be encoded and exposed to end users. User interfaces 
     * should instead mark these notes as "change notes" or "internal wallet operations". 
     */
    fun `changeAddress`(): ZcashDiversifierIndexAndPaymentAddress
    

    /**
     * Returns the change address corresponding to the specified diversifier, if any. 
     *  
     * In general, it is preferable to use `change_address` instead, but this method is 
     * useful in some cases for matching keys to existing payment addresses. 
     */
    fun `diversifiedChangeAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress?
    

    /**
     * Attempts to decrypt the given address's diversifier with this full viewing key. 
     *  
     * This method extracts the diversifier from the given address and decrypts it as a 
     * diversifier index, then verifies that this diversifier index produces the same 
     * address. Decryption is attempted using both the internal and external parts of the 
     * full viewing key. 
     *  
     * Returns the decrypted diversifier index and its scope, or `None` if the address 
     * was not generated from this key. 
     */
    fun `decryptDiversifier`(`addr`: ZcashPaymentAddress): ZcashDiversifierIndexAndScope?
    
}


/**
 * A Sapling key that provides the capability to view incoming and outgoing transactions. 
 *  
 * This key is useful anywhere you need to maintain accurate balance, but do not want the 
 * ability to spend funds (such as a view-only wallet). 
 *  
 * It comprises the subset of the ZIP 32 extended full viewing key that is used for the 
 * Sapling item in a [ZIP 316 Unified Full Viewing Key][zip-0316-ufvk]. 
 *  
 * [zip-0316-ufvk]: https://zips.z.cash/zip-0316#encoding-of-unified-full-incoming-viewing-keys 
 */
class ZcashDiversifiableFullViewingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashDiversifiableFullViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashDiversifiableFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `fvk`(): ZcashFullViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_fvk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashFullViewingKey.lift(it)
        }
    override fun `toNk`(`scope`: ZcashScope): ZcashNullifierDerivingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_to_nk(it, FfiConverterTypeZcashScope.lower(`scope`),  _status)
}
        }.let {
            FfiConverterTypeZcashNullifierDerivingKey.lift(it)
        }
    override fun `toIvk`(`scope`: ZcashScope): ZcashSaplingIvk =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_to_ivk(it, FfiConverterTypeZcashScope.lower(`scope`),  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingIvk.lift(it)
        }
    override fun `toOvk`(`scope`: ZcashScope): ZcashOutgoingViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_to_ovk(it, FfiConverterTypeZcashScope.lower(`scope`),  _status)
}
        }.let {
            FfiConverterTypeZcashOutgoingViewingKey.lift(it)
        }
    override fun `address`(`j`: ZcashDiversifierIndex): ZcashPaymentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashDiversifierIndexAndPaymentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_find_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_default_address(it,  _status)
}
        }.let {
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `diversifiedAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_diversified_address(it, FfiConverterTypeZcashDiversifier.lower(`diversifier`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `changeAddress`(): ZcashDiversifierIndexAndPaymentAddress =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_change_address(it,  _status)
}
        }.let {
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `diversifiedChangeAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_diversified_change_address(it, FfiConverterTypeZcashDiversifier.lower(`diversifier`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `decryptDiversifier`(`addr`: ZcashPaymentAddress): ZcashDiversifierIndexAndScope? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_decrypt_diversifier(it, FfiConverterTypeZcashPaymentAddress.lower(`addr`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashDiversifierIndexAndScope.lift(it)
        }
    

    companion object {
        

    /**
     * Parses a `DiversifiableFullViewingKey` from its raw byte encoding. 
     *  
     * Returns `None` if the bytes do not contain a valid encoding of a diversifiable 
     * Sapling full viewing key. 
     */
        fun `fromBytes`(`bytes`: List<UByte>): ZcashDiversifiableFullViewingKey =
            ZcashDiversifiableFullViewingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifiableFullViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashDiversifiableFullViewingKey: FfiConverter<ZcashDiversifiableFullViewingKey, Pointer> {
    override fun lower(value: ZcashDiversifiableFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashDiversifiableFullViewingKey {
        return ZcashDiversifiableFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashDiversifiableFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashDiversifiableFullViewingKey) = 8

    override fun write(value: ZcashDiversifiableFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashDiversifierInterface {
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashDiversifier(
    pointer: Pointer
) : FFIObject(pointer), ZcashDiversifierInterface {

    constructor(`bytes`: List<UByte>) :
        this(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifier_new(FfiConverterSequenceUByte.lower(`bytes`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashDiversifier_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifier_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashDiversifier: FfiConverter<ZcashDiversifier, Pointer> {
    override fun lower(value: ZcashDiversifier): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashDiversifier {
        return ZcashDiversifier(value)
    }

    override fun read(buf: ByteBuffer): ZcashDiversifier {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashDiversifier) = 8

    override fun write(value: ZcashDiversifier, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashDiversifierIndexInterface {
    

    @Throws(ZcashException::class)
    fun `increment`()
    

    @Throws(ZcashException::class)
    fun `toU32`(): UInt
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashDiversifierIndex(
    pointer: Pointer
) : FFIObject(pointer), ZcashDiversifierIndexInterface {

    constructor() :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifierIndex_new( _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashDiversifierIndex_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `increment`() =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifierIndex_increment(it,  _status)
}
        }
    
    
    @Throws(ZcashException::class)override fun `toU32`(): UInt =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifierIndex_to_u32(it,  _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifierIndex_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromU32`(`i`: UInt): ZcashDiversifierIndex =
            ZcashDiversifierIndex(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifierIndex_from_u32(FfiConverterUInt.lower(`i`), _status)
})
        

        fun `fromU64`(`i`: ULong): ZcashDiversifierIndex =
            ZcashDiversifierIndex(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashDiversifierIndex_from_u64(FfiConverterULong.lower(`i`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashDiversifierIndex: FfiConverter<ZcashDiversifierIndex, Pointer> {
    override fun lower(value: ZcashDiversifierIndex): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashDiversifierIndex {
        return ZcashDiversifierIndex(value)
    }

    override fun read(buf: ByteBuffer): ZcashDiversifierIndex {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashDiversifierIndex) = 8

    override fun write(value: ZcashDiversifierIndex, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashExpandedSpendingKeyInterface {
    

    fun `proofGenerationKey`(): ZcashProofGenerationKey
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashExpandedSpendingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashExpandedSpendingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashExpandedSpendingKey_object_free(this.pointer, status)
        }
    }

    override fun `proofGenerationKey`(): ZcashProofGenerationKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExpandedSpendingKey_proof_generation_key(it,  _status)
}
        }.let {
            FfiConverterTypeZcashProofGenerationKey.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExpandedSpendingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromSpendingKey`(`sk`: List<UByte>): ZcashExpandedSpendingKey =
            ZcashExpandedSpendingKey(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExpandedSpendingKey_from_spending_key(FfiConverterSequenceUByte.lower(`sk`), _status)
})
        

        fun `fromBytes`(`b`: List<UByte>): ZcashExpandedSpendingKey =
            ZcashExpandedSpendingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExpandedSpendingKey_from_bytes(FfiConverterSequenceUByte.lower(`b`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashExpandedSpendingKey: FfiConverter<ZcashExpandedSpendingKey, Pointer> {
    override fun lower(value: ZcashExpandedSpendingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExpandedSpendingKey {
        return ZcashExpandedSpendingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashExpandedSpendingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExpandedSpendingKey) = 8

    override fun write(value: ZcashExpandedSpendingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashExtendedFullViewingKeyInterface {
    

    fun `encode`(`params`: ZcashConsensusParameters): String
    

    fun `toBytes`(): List<UByte>
    

    fun `address`(`j`: ZcashDiversifierIndex): ZcashPaymentAddress?
    

    @Throws(ZcashException::class)
    fun `deriveChild`(`i`: ZcashChildIndex): ZcashExtendedFullViewingKey
    

    fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashDiversifierIndexAndPaymentAddress?
    

    fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress
    

    fun `deriveInternal`(): ZcashExtendedFullViewingKey
    

    fun `toDiversifiableFullViewingKey`(): ZcashDiversifiableFullViewingKey
    
}


class ZcashExtendedFullViewingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashExtendedFullViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashExtendedFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `address`(`j`: ZcashDiversifierIndex): ZcashPaymentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `deriveChild`(`i`: ZcashChildIndex): ZcashExtendedFullViewingKey =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_derive_child(it, FfiConverterTypeZcashChildIndex.lower(`i`),  _status)
}
        }.let {
            FfiConverterTypeZcashExtendedFullViewingKey.lift(it)
        }
    override fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashDiversifierIndexAndPaymentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_find_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_default_address(it,  _status)
}
        }.let {
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `deriveInternal`(): ZcashExtendedFullViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_derive_internal(it,  _status)
}
        }.let {
            FfiConverterTypeZcashExtendedFullViewingKey.lift(it)
        }
    override fun `toDiversifiableFullViewingKey`(): ZcashDiversifiableFullViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key(it,  _status)
}
        }.let {
            FfiConverterTypeZcashDiversifiableFullViewingKey.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`bytes`: List<UByte>): ZcashExtendedFullViewingKey =
            ZcashExtendedFullViewingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        

        fun `decode`(`params`: ZcashConsensusParameters, `input`: String): ZcashExtendedFullViewingKey =
            ZcashExtendedFullViewingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedFullViewingKey_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`input`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashExtendedFullViewingKey: FfiConverter<ZcashExtendedFullViewingKey, Pointer> {
    override fun lower(value: ZcashExtendedFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExtendedFullViewingKey {
        return ZcashExtendedFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashExtendedFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExtendedFullViewingKey) = 8

    override fun write(value: ZcashExtendedFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashExtendedPrivKeyInterface {
    

    fun `toBytes`(): List<UByte>
    

    /**
     * Derive a child key from ExtendedPrivKey. 
     */
    @Throws(ZcashException::class)
    fun `derivePrivateKey`(`keyIndex`: ZcashKeyIndex): ZcashExtendedPrivKey
    
}


/**
 * ExtendedPrivKey is used for child key derivation. 
 * See [secp256k1 crate documentation](https://docs.rs/secp256k1) for SecretKey signatures usage. 
 */
class ZcashExtendedPrivKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashExtendedPrivKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashExtendedPrivKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedPrivKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `derivePrivateKey`(`keyIndex`: ZcashKeyIndex): ZcashExtendedPrivKey =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedPrivKey_derive_private_key(it, FfiConverterTypeZcashKeyIndex.lower(`keyIndex`),  _status)
}
        }.let {
            FfiConverterTypeZcashExtendedPrivKey.lift(it)
        }
    

    companion object {
        

    /**
     * Generate an ExtendedPrivKey, use 256 size random seed. 
     *  
     * Note: it uses [`ThreadRng`](https://docs.rs/rand/latest/rand/rngs/struct.ThreadRng.html) 
     * obtained with [`thread_rng`](https://docs.rs/rand/latest/rand/fn.thread_rng.html) as 
     * random number generator. 
     */
        fun `random`(): ZcashExtendedPrivKey =
            ZcashExtendedPrivKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedPrivKey_random( _status)
})
        

        fun `fromBytes`(`bytes`: List<UByte>): ZcashExtendedPrivKey =
            ZcashExtendedPrivKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedPrivKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        

    /**
     * Generate an ExtendedPrivKey which use 128 or 256 or 512 bits random seed. 
     *  
     * Note: it uses [`ThreadRng`](https://docs.rs/rand/latest/rand/rngs/struct.ThreadRng.html) 
     * obtained with [`thread_rng`](https://docs.rs/rand/latest/rand/fn.thread_rng.html) as 
     * random number generator. 
     */
        fun `randomWithSeedSize`(`seedSize`: ZcashKeySeed): ZcashExtendedPrivKey =
            ZcashExtendedPrivKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedPrivKey_random_with_seed_size(FfiConverterTypeZcashKeySeed.lower(`seedSize`), _status)
})
        

    /**
     * Generate an ExtendedPrivKey from seed 
     */
        fun `withSeed`(`data`: List<UByte>): ZcashExtendedPrivKey =
            ZcashExtendedPrivKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedPrivKey_with_seed(FfiConverterSequenceUByte.lower(`data`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashExtendedPrivKey: FfiConverter<ZcashExtendedPrivKey, Pointer> {
    override fun lower(value: ZcashExtendedPrivKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExtendedPrivKey {
        return ZcashExtendedPrivKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashExtendedPrivKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExtendedPrivKey) = 8

    override fun write(value: ZcashExtendedPrivKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashExtendedSpendingKeyInterface {
    

    fun `encode`(`params`: ZcashConsensusParameters): String
    

    fun `toBytes`(): List<UByte>
    

    fun `deriveChild`(`index`: ZcashChildIndex): ZcashExtendedSpendingKey
    

    fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress
    

    fun `deriveInternal`(): ZcashExtendedSpendingKey
    

    fun `toDiversifiableFullViewingKey`(): ZcashDiversifiableFullViewingKey
    
}


class ZcashExtendedSpendingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashExtendedSpendingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashExtendedSpendingKey_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `deriveChild`(`index`: ZcashChildIndex): ZcashExtendedSpendingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_derive_child(it, FfiConverterTypeZcashChildIndex.lower(`index`),  _status)
}
        }.let {
            FfiConverterTypeZcashExtendedSpendingKey.lift(it)
        }
    override fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_default_address(it,  _status)
}
        }.let {
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `deriveInternal`(): ZcashExtendedSpendingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_derive_internal(it,  _status)
}
        }.let {
            FfiConverterTypeZcashExtendedSpendingKey.lift(it)
        }
    override fun `toDiversifiableFullViewingKey`(): ZcashDiversifiableFullViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key(it,  _status)
}
        }.let {
            FfiConverterTypeZcashDiversifiableFullViewingKey.lift(it)
        }
    

    companion object {
        

        fun `master`(`data`: List<UByte>): ZcashExtendedSpendingKey =
            ZcashExtendedSpendingKey(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_master(FfiConverterSequenceUByte.lower(`data`), _status)
})
        

        fun `fromBytes`(`data`: List<UByte>): ZcashExtendedSpendingKey =
            ZcashExtendedSpendingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        

        fun `fromPath`(`master`: ZcashExtendedSpendingKey, `path`: List<ZcashChildIndex>): ZcashExtendedSpendingKey =
            ZcashExtendedSpendingKey(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_from_path(FfiConverterTypeZcashExtendedSpendingKey.lower(`master`), FfiConverterSequenceTypeZcashChildIndex.lower(`path`), _status)
})
        

        fun `decode`(`params`: ZcashConsensusParameters, `input`: String): ZcashExtendedSpendingKey =
            ZcashExtendedSpendingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtendedSpendingKey_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`input`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashExtendedSpendingKey: FfiConverter<ZcashExtendedSpendingKey, Pointer> {
    override fun lower(value: ZcashExtendedSpendingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExtendedSpendingKey {
        return ZcashExtendedSpendingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashExtendedSpendingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExtendedSpendingKey) = 8

    override fun write(value: ZcashExtendedSpendingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashExternalIvkInterface {
    

    @Throws(ZcashException::class)
    fun `deriveAddress`(`childIndex`: UInt): ZcashTransparentAddress
    

    /**
     * Searches the space of child indexes for an index that will 
     * generate a valid transparent address, and returns the resulting 
     * address and the index at which it was generated. 
     */
    fun `defaultAddress`(): ZcashTransparentAddressAndIndex
    

    fun `toBytes`(): List<UByte>
    
}


/**
 * A type representing an incoming viewing key at the BIP-44 "external" 
 * path `m/44'/<coin_type>'/<account>'/0`. This allows derivation 
 * of child addresses that may be provided to external parties. 
 */
class ZcashExternalIvk(
    pointer: Pointer
) : FFIObject(pointer), ZcashExternalIvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashExternalIvk_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `deriveAddress`(`childIndex`: UInt): ZcashTransparentAddress =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExternalIvk_derive_address(it, FfiConverterUInt.lower(`childIndex`),  _status)
}
        }.let {
            FfiConverterTypeZcashTransparentAddress.lift(it)
        }
    override fun `defaultAddress`(): ZcashTransparentAddressAndIndex =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExternalIvk_default_address(it,  _status)
}
        }.let {
            FfiConverterTypeZcashTransparentAddressAndIndex.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExternalIvk_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>): ZcashExternalIvk =
            ZcashExternalIvk(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExternalIvk_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashExternalIvk: FfiConverter<ZcashExternalIvk, Pointer> {
    override fun lower(value: ZcashExternalIvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExternalIvk {
        return ZcashExternalIvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashExternalIvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExternalIvk) = 8

    override fun write(value: ZcashExternalIvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashExternalOvkInterface {
    

    fun `asBytes`(): List<UByte>
    
}


/**
 * ExternalOVK 
 */
class ZcashExternalOvk(
    pointer: Pointer
) : FFIObject(pointer), ZcashExternalOvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashExternalOvk_object_free(this.pointer, status)
        }
    }

    override fun `asBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExternalOvk_as_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashExternalOvk: FfiConverter<ZcashExternalOvk, Pointer> {
    override fun lower(value: ZcashExternalOvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExternalOvk {
        return ZcashExternalOvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashExternalOvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExternalOvk) = 8

    override fun write(value: ZcashExternalOvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashExtractedNoteCommitmentInterface {
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashExtractedNoteCommitment(
    pointer: Pointer
) : FFIObject(pointer), ZcashExtractedNoteCommitmentInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashExtractedNoteCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtractedNoteCommitment_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>): ZcashExtractedNoteCommitment =
            ZcashExtractedNoteCommitment(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashExtractedNoteCommitment_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashExtractedNoteCommitment: FfiConverter<ZcashExtractedNoteCommitment, Pointer> {
    override fun lower(value: ZcashExtractedNoteCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExtractedNoteCommitment {
        return ZcashExtractedNoteCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashExtractedNoteCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExtractedNoteCommitment) = 8

    override fun write(value: ZcashExtractedNoteCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashFixedFeeRuleInterface {
    

    /**
     * Returns the fixed fee amount which which this rule was configured. 
     */
    fun `fixedFee`(): ZcashAmount
    
}


/**
 * A fee rule that always returns a fixed fee, irrespective of the structure of 
 * the transaction being constructed. 
 */
class ZcashFixedFeeRule(
    pointer: Pointer
) : FFIObject(pointer), ZcashFixedFeeRuleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashFixedFeeRule_object_free(this.pointer, status)
        }
    }

    override fun `fixedFee`(): ZcashAmount =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashFixedFeeRule_fixed_fee(it,  _status)
}
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }
    

    companion object {
        

    /**
     * Creates a new nonstandard fixed fee rule with the specified fixed fee. 
     */
        fun `nonStandard`(`fixedFee`: ZcashAmount): ZcashFixedFeeRule =
            ZcashFixedFeeRule(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashFixedFeeRule_non_standard(FfiConverterTypeZcashAmount.lower(`fixedFee`), _status)
})
        

    /**
     * Creates a new fixed fee rule with the standard default fee. 
     */
        fun `standard`(): ZcashFixedFeeRule =
            ZcashFixedFeeRule(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashFixedFeeRule_standard( _status)
})
        
    }
    
}

public object FfiConverterTypeZcashFixedFeeRule: FfiConverter<ZcashFixedFeeRule, Pointer> {
    override fun lower(value: ZcashFixedFeeRule): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashFixedFeeRule {
        return ZcashFixedFeeRule(value)
    }

    override fun read(buf: ByteBuffer): ZcashFixedFeeRule {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashFixedFeeRule) = 8

    override fun write(value: ZcashFixedFeeRule, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashFullViewingKeyInterface {
    

    fun `toBytes`(): List<UByte>
    

    fun `vk`(): ZcashViewingKey
    

    fun `ovk`(): ZcashOutgoingViewingKey
    
}


class ZcashFullViewingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashFullViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashFullViewingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `vk`(): ZcashViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashFullViewingKey_vk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashViewingKey.lift(it)
        }
    override fun `ovk`(): ZcashOutgoingViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashFullViewingKey_ovk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOutgoingViewingKey.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`bytes`: List<UByte>): ZcashFullViewingKey =
            ZcashFullViewingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashFullViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        

        fun `fromExpandedSpendingKey`(`expsk`: ZcashExpandedSpendingKey): ZcashFullViewingKey =
            ZcashFullViewingKey(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashFullViewingKey_from_expanded_spending_key(FfiConverterTypeZcashExpandedSpendingKey.lower(`expsk`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashFullViewingKey: FfiConverter<ZcashFullViewingKey, Pointer> {
    override fun lower(value: ZcashFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashFullViewingKey {
        return ZcashFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashFullViewingKey) = 8

    override fun write(value: ZcashFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashIncrementalWitnessInterface {
    

    @Throws(ZcashException::class)
    fun `append`(`node`: ZcashSaplingNode)
    

    fun `path`(): ZcashSaplingMerklePath?
    
}


class ZcashIncrementalWitness(
    pointer: Pointer
) : FFIObject(pointer), ZcashIncrementalWitnessInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashIncrementalWitness_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `append`(`node`: ZcashSaplingNode) =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashIncrementalWitness_append(it, FfiConverterTypeZcashSaplingNode.lower(`node`),  _status)
}
        }
    
    override fun `path`(): ZcashSaplingMerklePath? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashIncrementalWitness_path(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashSaplingMerklePath.lift(it)
        }
    

    companion object {
        

        fun `fromTree`(`tree`: ZcashCommitmentTree): ZcashIncrementalWitness =
            ZcashIncrementalWitness(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashIncrementalWitness_from_tree(FfiConverterTypeZcashCommitmentTree.lower(`tree`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashIncrementalWitness: FfiConverter<ZcashIncrementalWitness, Pointer> {
    override fun lower(value: ZcashIncrementalWitness): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashIncrementalWitness {
        return ZcashIncrementalWitness(value)
    }

    override fun read(buf: ByteBuffer): ZcashIncrementalWitness {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashIncrementalWitness) = 8

    override fun write(value: ZcashIncrementalWitness, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashInternalIvkInterface {
    

    fun `defaultAddress`(): ZcashTransparentAddressAndIndex
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashInternalIvk(
    pointer: Pointer
) : FFIObject(pointer), ZcashInternalIvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashInternalIvk_object_free(this.pointer, status)
        }
    }

    override fun `defaultAddress`(): ZcashTransparentAddressAndIndex =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashInternalIvk_default_address(it,  _status)
}
        }.let {
            FfiConverterTypeZcashTransparentAddressAndIndex.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashInternalIvk_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>): ZcashInternalIvk =
            ZcashInternalIvk(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashInternalIvk_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashInternalIvk: FfiConverter<ZcashInternalIvk, Pointer> {
    override fun lower(value: ZcashInternalIvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashInternalIvk {
        return ZcashInternalIvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashInternalIvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashInternalIvk) = 8

    override fun write(value: ZcashInternalIvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashInternalOvkInterface {
    

    fun `asBytes`(): List<UByte>
    
}


/**
 * InternalOVK 
 */
class ZcashInternalOvk(
    pointer: Pointer
) : FFIObject(pointer), ZcashInternalOvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashInternalOvk_object_free(this.pointer, status)
        }
    }

    override fun `asBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashInternalOvk_as_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashInternalOvk: FfiConverter<ZcashInternalOvk, Pointer> {
    override fun lower(value: ZcashInternalOvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashInternalOvk {
        return ZcashInternalOvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashInternalOvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashInternalOvk) = 8

    override fun write(value: ZcashInternalOvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashJubjubFrInterface {
    

    fun `toBytes`(): List<UByte>
    
}


/**
 * Represents an element of the scalar field $\mathbb{F}_r$ of the Jubjub elliptic 
 * curve construction. 
 */
class ZcashJubjubFr(
    pointer: Pointer
) : FFIObject(pointer), ZcashJubjubFrInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashJubjubFr_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashJubjubFr_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>): ZcashJubjubFr =
            ZcashJubjubFr(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashJubjubFr_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashJubjubFr: FfiConverter<ZcashJubjubFr, Pointer> {
    override fun lower(value: ZcashJubjubFr): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashJubjubFr {
        return ZcashJubjubFr(value)
    }

    override fun read(buf: ByteBuffer): ZcashJubjubFr {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashJubjubFr) = 8

    override fun write(value: ZcashJubjubFr, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashKeyIndexInterface {
    

    /**
     * Return raw index value 
     */
    fun `rawIndex`(): UInt
    

    /**
     * Return normalize index, it will return index subtract 2 ** 31 for hardended key. 
     */
    fun `normalizeIndex`(): UInt
    

    /**
     * Check index range. 
     */
    fun `isValid`(): Boolean
    
}


/**
 * KeyIndex indicates the key type and index of a child key. 
 */
class ZcashKeyIndex(
    pointer: Pointer
) : FFIObject(pointer), ZcashKeyIndexInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashKeyIndex_object_free(this.pointer, status)
        }
    }

    override fun `rawIndex`(): UInt =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashKeyIndex_raw_index(it,  _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `normalizeIndex`(): UInt =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashKeyIndex_normalize_index(it,  _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `isValid`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashKeyIndex_is_valid(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    

    companion object {
        

    /**
     * DUPLICATE ? 
     */
        fun `fromU32`(`i`: UInt): ZcashKeyIndex =
            ZcashKeyIndex(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashKeyIndex_from_u32(FfiConverterUInt.lower(`i`), _status)
})
        

    /**
     * Generate Hardened KeyIndex from normalize index value. 
     */
        fun `hardenedFromNormalizeIndex`(`i`: UInt): ZcashKeyIndex =
            ZcashKeyIndex(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashKeyIndex_hardened_from_normalize_index(FfiConverterUInt.lower(`i`), _status)
})
        

    /**
     * Generate KeyIndex from raw index value. 
     */
        fun `fromIndex`(`i`: UInt): ZcashKeyIndex =
            ZcashKeyIndex(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashKeyIndex_from_index(FfiConverterUInt.lower(`i`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashKeyIndex: FfiConverter<ZcashKeyIndex, Pointer> {
    override fun lower(value: ZcashKeyIndex): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashKeyIndex {
        return ZcashKeyIndex(value)
    }

    override fun read(buf: ByteBuffer): ZcashKeyIndex {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashKeyIndex) = 8

    override fun write(value: ZcashKeyIndex, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashLocalTxProverInterface {
    
}


class ZcashLocalTxProver(
    pointer: Pointer
) : FFIObject(pointer), ZcashLocalTxProverInterface {

    constructor(`spendPath`: String, `outputPath`: String) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashLocalTxProver_new(FfiConverterString.lower(`spendPath`), FfiConverterString.lower(`outputPath`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashLocalTxProver_object_free(this.pointer, status)
        }
    }

    

    companion object {
        

        fun `fromBytes`(`spendParamBytes`: List<UByte>, `outputParamBytes`: List<UByte>): ZcashLocalTxProver =
            ZcashLocalTxProver(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashLocalTxProver_from_bytes(FfiConverterSequenceUByte.lower(`spendParamBytes`), FfiConverterSequenceUByte.lower(`outputParamBytes`), _status)
})
        

        fun `withDefaultLocation`(): ZcashLocalTxProver =
            ZcashLocalTxProver(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashLocalTxProver_with_default_location( _status)
})
        
    }
    
}

public object FfiConverterTypeZcashLocalTxProver: FfiConverter<ZcashLocalTxProver, Pointer> {
    override fun lower(value: ZcashLocalTxProver): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashLocalTxProver {
        return ZcashLocalTxProver(value)
    }

    override fun read(buf: ByteBuffer): ZcashLocalTxProver {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashLocalTxProver) = 8

    override fun write(value: ZcashLocalTxProver, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashMemoBytesInterface {
    

    fun `data`(): List<UByte>
    
}


class ZcashMemoBytes(
    pointer: Pointer
) : FFIObject(pointer), ZcashMemoBytesInterface {

    constructor(`data`: List<UByte>) :
        this(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashMemoBytes_new(FfiConverterSequenceUByte.lower(`data`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashMemoBytes_object_free(this.pointer, status)
        }
    }

    override fun `data`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashMemoBytes_data(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `empty`(): ZcashMemoBytes =
            ZcashMemoBytes(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashMemoBytes_empty( _status)
})
        
    }
    
}

public object FfiConverterTypeZcashMemoBytes: FfiConverter<ZcashMemoBytes, Pointer> {
    override fun lower(value: ZcashMemoBytes): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashMemoBytes {
        return ZcashMemoBytes(value)
    }

    override fun read(buf: ByteBuffer): ZcashMemoBytes {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashMemoBytes) = 8

    override fun write(value: ZcashMemoBytes, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashNullifierDerivingKeyInterface {
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashNullifierDerivingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashNullifierDerivingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashNullifierDerivingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashNullifierDerivingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`bytes`: List<UByte>): ZcashNullifierDerivingKey =
            ZcashNullifierDerivingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashNullifierDerivingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashNullifierDerivingKey: FfiConverter<ZcashNullifierDerivingKey, Pointer> {
    override fun lower(value: ZcashNullifierDerivingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashNullifierDerivingKey {
        return ZcashNullifierDerivingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashNullifierDerivingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashNullifierDerivingKey) = 8

    override fun write(value: ZcashNullifierDerivingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardActionInterface {
    

    /**
     * Returns the nullifier of the note being spent. 
     */
    fun `nullifier`(): ZcashOrchardNullifier
    

    /**
     * Returns the commitment to the new note being created. 
     */
    fun `cmx`(): ZcashExtractedNoteCommitment
    

    /**
     * Returns the encrypted note ciphertext. 
     */
    fun `encryptedNote`(): ZcashOrchardTransmittedNoteCiphertext
    

    /**
     * Returns the commitment to the net value created or consumed by this action. 
     */
    fun `cvNet`(): ZcashOrchardValueCommitment
    
}


/**
 * An action applied to the global ledger. 
 *  
 * Externally, this both creates a note (adding a commitment to the global ledger), 
 * and consumes some note created prior to this action (adding a nullifier to the 
 * global ledger). 
 *  
 * Internally, this may both consume a note and create a note, or it may do only one of 
 * the two. TODO: Determine which is more efficient (circuit size vs bundle size). 
 */
class ZcashOrchardAction(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardActionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardAction_object_free(this.pointer, status)
        }
    }

    override fun `nullifier`(): ZcashOrchardNullifier =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardAction_nullifier(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardNullifier.lift(it)
        }
    override fun `cmx`(): ZcashExtractedNoteCommitment =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardAction_cmx(it,  _status)
}
        }.let {
            FfiConverterTypeZcashExtractedNoteCommitment.lift(it)
        }
    override fun `encryptedNote`(): ZcashOrchardTransmittedNoteCiphertext =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardAction_encrypted_note(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardTransmittedNoteCiphertext.lift(it)
        }
    override fun `cvNet`(): ZcashOrchardValueCommitment =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardAction_cv_net(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardValueCommitment.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashOrchardAction: FfiConverter<ZcashOrchardAction, Pointer> {
    override fun lower(value: ZcashOrchardAction): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardAction {
        return ZcashOrchardAction(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardAction {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardAction) = 8

    override fun write(value: ZcashOrchardAction, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardAddressInterface {
    

    /**
     * Returns the [`Diversifier`] for this `Address`. 
     */
    fun `diversifier`(): ZcashOrchardDiversifier
    

    /**
     * Serializes this address to its "raw" encoding as specified in [Zcash Protocol Spec § 5.6.4.2: Orchard Raw Payment Addresses][orchardpaymentaddrencoding] 
     *  
     * [orchardpaymentaddrencoding]: https://zips.z.cash/protocol/protocol.pdf#orchardpaymentaddrencoding 
     */
    fun `toRawAddressBytes`(): List<UByte>
    
}


/**
 * A shielded payment address. 
 */
class ZcashOrchardAddress(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardAddressInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardAddress_object_free(this.pointer, status)
        }
    }

    override fun `diversifier`(): ZcashOrchardDiversifier =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardAddress_diversifier(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardDiversifier.lift(it)
        }
    override fun `toRawAddressBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardAddress_to_raw_address_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

    /**
     * Parse an address from its "raw" encoding as specified in [Zcash Protocol Spec § 5.6.4.2: Orchard Raw Payment Addresses][orchardpaymentaddrencoding] 
     *  
     * [orchardpaymentaddrencoding]: https://zips.z.cash/protocol/protocol.pdf#orchardpaymentaddrencoding 
     */
        fun `fromRawAddressBytes`(`bytes`: List<UByte>): ZcashOrchardAddress =
            ZcashOrchardAddress(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardAddress_from_raw_address_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardAddress: FfiConverter<ZcashOrchardAddress, Pointer> {
    override fun lower(value: ZcashOrchardAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardAddress {
        return ZcashOrchardAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardAddress) = 8

    override fun write(value: ZcashOrchardAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardBundleInterface {
    

    /**
     * The list of actions that make up this bundle. 
     */
    fun `actions`(): List<ZcashOrchardAction>
    

    /**
     * Returns the Orchard-specific transaction-level flags for this bundle. 
     */
    fun `flags`(): ZcashOrchardFlags
    

    /**
     * Returns the net value moved into or out of the Orchard shielded pool. 
     *  
     * This is the sum of Orchard spends minus the sum Orchard outputs. 
     */
    fun `valueBalance`(): ZcashAmount
    

    /**
     * Returns the root of the Orchard commitment tree that this bundle commits to. 
     */
    fun `anchor`(): ZcashAnchor
    

    /**
     * Verifies the proof for this bundle. 
     */
    @Throws(ZcashException::class)
    fun `verifyProof`(`key`: ZcashVerifyingKey)
    

    /**
     * Performs trial decryption of the action at `action_idx` in the bundle with the 
     * specified incoming viewing key, and returns the decrypted note plaintext 
     * contents if successful. 
     */
    @Throws(ZcashException::class)
    fun `decryptOutputWithKey`(`actionIdx`: ULong, `ivk`: ZcashOrchardIncomingViewingKey): ZcashOrchardDecryptOutput
    

    /**
     * Performs trial decryption of each action in the bundle with each of the 
     * specified incoming viewing keys, and returns a vector of each decrypted 
     * note plaintext contents along with the index of the action from which it 
     * was derived. 
     */
    fun `decryptOutputWithKeys`(`ivks`: List<ZcashOrchardIncomingViewingKey>): List<ZcashOrchardDecryptOutputForIncomingKeys>
    

    /**
     * Attempts to decrypt the action at the specified index with the specified 
     * outgoing viewing key, and returns the decrypted note plaintext contents 
     * if successful. 
     */
    @Throws(ZcashException::class)
    fun `recoverOutputWithOvk`(`actionIdx`: ULong, `ovk`: ZcashOrchardOutgoingViewingKey): ZcashOrchardDecryptOutput
    

    /**
     * Performs trial decryption of each action in the bundle with each of the 
     * specified outgoing viewing keys, and returns a vector of each decrypted 
     * note plaintext contents along with the index of the action from which it 
     * was derived. 
     */
    fun `recoverOutputsWithOvks`(`ovks`: List<ZcashOrchardOutgoingViewingKey>): List<ZcashOrchardDecryptOutputForOutgoingKeys>
    
}


/**
 * A bundle of actions to be applied to the ledger. 
 */
class ZcashOrchardBundle(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardBundleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardBundle_object_free(this.pointer, status)
        }
    }

    override fun `actions`(): List<ZcashOrchardAction> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardBundle_actions(it,  _status)
}
        }.let {
            FfiConverterSequenceTypeZcashOrchardAction.lift(it)
        }
    override fun `flags`(): ZcashOrchardFlags =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardBundle_flags(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardFlags.lift(it)
        }
    override fun `valueBalance`(): ZcashAmount =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardBundle_value_balance(it,  _status)
}
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }
    override fun `anchor`(): ZcashAnchor =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardBundle_anchor(it,  _status)
}
        }.let {
            FfiConverterTypeZcashAnchor.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `verifyProof`(`key`: ZcashVerifyingKey) =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardBundle_verify_proof(it, FfiConverterTypeZcashVerifyingKey.lower(`key`),  _status)
}
        }
    
    
    @Throws(ZcashException::class)override fun `decryptOutputWithKey`(`actionIdx`: ULong, `ivk`: ZcashOrchardIncomingViewingKey): ZcashOrchardDecryptOutput =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardBundle_decrypt_output_with_key(it, FfiConverterULong.lower(`actionIdx`), FfiConverterTypeZcashOrchardIncomingViewingKey.lower(`ivk`),  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardDecryptOutput.lift(it)
        }
    override fun `decryptOutputWithKeys`(`ivks`: List<ZcashOrchardIncomingViewingKey>): List<ZcashOrchardDecryptOutputForIncomingKeys> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardBundle_decrypt_output_with_keys(it, FfiConverterSequenceTypeZcashOrchardIncomingViewingKey.lower(`ivks`),  _status)
}
        }.let {
            FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `recoverOutputWithOvk`(`actionIdx`: ULong, `ovk`: ZcashOrchardOutgoingViewingKey): ZcashOrchardDecryptOutput =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardBundle_recover_output_with_ovk(it, FfiConverterULong.lower(`actionIdx`), FfiConverterTypeZcashOrchardOutgoingViewingKey.lower(`ovk`),  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardDecryptOutput.lift(it)
        }
    override fun `recoverOutputsWithOvks`(`ovks`: List<ZcashOrchardOutgoingViewingKey>): List<ZcashOrchardDecryptOutputForOutgoingKeys> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardBundle_recover_outputs_with_ovks(it, FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey.lower(`ovks`),  _status)
}
        }.let {
            FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashOrchardBundle: FfiConverter<ZcashOrchardBundle, Pointer> {
    override fun lower(value: ZcashOrchardBundle): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardBundle {
        return ZcashOrchardBundle(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardBundle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardBundle) = 8

    override fun write(value: ZcashOrchardBundle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardDiversifierInterface {
    

    fun `toBytes`(): List<UByte>
    
}


/**
 * A diversifier that can be used to derive a specific [`Address`] from a 
 * [`FullViewingKey`] or [`IncomingViewingKey`]. 
 */
class ZcashOrchardDiversifier(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardDiversifierInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardDiversifier_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardDiversifier_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`bytes`: List<UByte>): ZcashOrchardDiversifier =
            ZcashOrchardDiversifier(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardDiversifier_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardDiversifier: FfiConverter<ZcashOrchardDiversifier, Pointer> {
    override fun lower(value: ZcashOrchardDiversifier): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardDiversifier {
        return ZcashOrchardDiversifier(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardDiversifier {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardDiversifier) = 8

    override fun write(value: ZcashOrchardDiversifier, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardDiversifierIndexInterface {
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashOrchardDiversifierIndex(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardDiversifierIndexInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardDiversifierIndex_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardDiversifierIndex_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`b`: List<UByte>): ZcashOrchardDiversifierIndex =
            ZcashOrchardDiversifierIndex(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardDiversifierIndex_from_bytes(FfiConverterSequenceUByte.lower(`b`), _status)
})
        

        fun `fromU32`(`i`: UInt): ZcashOrchardDiversifierIndex =
            ZcashOrchardDiversifierIndex(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardDiversifierIndex_from_u32(FfiConverterUInt.lower(`i`), _status)
})
        

        fun `fromU64`(`i`: ULong): ZcashOrchardDiversifierIndex =
            ZcashOrchardDiversifierIndex(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardDiversifierIndex_from_u64(FfiConverterULong.lower(`i`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardDiversifierIndex: FfiConverter<ZcashOrchardDiversifierIndex, Pointer> {
    override fun lower(value: ZcashOrchardDiversifierIndex): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardDiversifierIndex {
        return ZcashOrchardDiversifierIndex(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardDiversifierIndex {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardDiversifierIndex) = 8

    override fun write(value: ZcashOrchardDiversifierIndex, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardFlagsInterface {
    

    /**
     * Flag denoting whether Orchard spends are enabled in the transaction. 
     *  
     * If `false`, spent notes within [`Action`]s in the transaction's [`Bundle`] are 
     * guaranteed to be dummy notes. If `true`, the spent notes may be either real or 
     * dummy notes. 
     */
    fun `spendsEnabled`(): Boolean
    

    /**
     * Flag denoting whether Orchard outputs are enabled in the transaction. 
     *  
     * If `false`, created notes within [`Action`]s in the transaction's [`Bundle`] are 
     * guaranteed to be dummy notes. If `true`, the created notes may be either real or 
     * dummy notes. 
     */
    fun `outputsEnabled`(): Boolean
    

    /**
     * Serialize flags to a byte as defined in [Zcash Protocol Spec § 7.1: Transaction 
     * Encoding And Consensus][txencoding]. 
     *  
     * [txencoding]: https://zips.z.cash/protocol/protocol.pdf#txnencoding 
     */
    fun `toByte`(): UByte
    
}


/**
 * Orchard-specific flags. 
 */
class ZcashOrchardFlags(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardFlagsInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardFlags_object_free(this.pointer, status)
        }
    }

    override fun `spendsEnabled`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFlags_spends_enabled(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `outputsEnabled`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFlags_outputs_enabled(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `toByte`(): UByte =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFlags_to_byte(it,  _status)
}
        }.let {
            FfiConverterUByte.lift(it)
        }
    

    companion object {
        

    /**
     * Construct a set of flags from its constituent parts 
     */
        fun `fromParts`(`spendsEnabled`: Boolean, `outputsEnabled`: Boolean): ZcashOrchardFlags =
            ZcashOrchardFlags(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFlags_from_parts(FfiConverterBoolean.lower(`spendsEnabled`), FfiConverterBoolean.lower(`outputsEnabled`), _status)
})
        

    /**
     * Parses flags from a single byte as defined in [Zcash Protocol Spec § 7.1: 
     * Transaction Encoding And Consensus][txencoding]. 
     *  
     * Returns `None` if unexpected bits are set in the flag byte. 
     *  
     * [txencoding]: https://zips.z.cash/protocol/protocol.pdf#txnencoding 
     */
        fun `fromByte`(`v`: UByte): ZcashOrchardFlags =
            ZcashOrchardFlags(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFlags_from_byte(FfiConverterUByte.lower(`v`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardFlags: FfiConverter<ZcashOrchardFlags, Pointer> {
    override fun lower(value: ZcashOrchardFlags): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardFlags {
        return ZcashOrchardFlags(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardFlags {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardFlags) = 8

    override fun write(value: ZcashOrchardFlags, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardFullViewingKeyInterface {
    

    /**
     * Returns the payment address for this key at the given index. 
     */
    fun `addressAt`(`j`: ZcashOrchardDiversifierIndex, `scope`: ZcashOrchardScope): ZcashOrchardAddress
    

    /**
     * Returns the payment address for this key corresponding to the given diversifier. 
     */
    fun `address`(`d`: ZcashOrchardDiversifier, `scope`: ZcashOrchardScope): ZcashOrchardAddress
    

    /**
     * Returns the scope of the given address, or `None` if the address is not derived 
     * from this full viewing key. 
     */
    fun `scopeForAddress`(`address`: ZcashOrchardAddress): ZcashOrchardScope?
    

    /**
     * Serializes the full viewing key as specified in [Zcash Protocol Spec § 5.6.4.4: Orchard Raw Full Viewing Keys][orchardrawfullviewingkeys] 
     *  
     * [orchardrawfullviewingkeys]: https://zips.z.cash/protocol/protocol.pdf#orchardfullviewingkeyencoding 
     */
    fun `toBytes`(): List<UByte>
    

    /**
     * Derives an `IncomingViewingKey` for this full viewing key. 
     */
    fun `toIvk`(`scope`: ZcashOrchardScope): ZcashOrchardIncomingViewingKey
    

    /**
     * Derives an `OutgoingViewingKey` for this full viewing key. 
     */
    fun `toOvk`(`scope`: ZcashOrchardScope): ZcashOrchardOutgoingViewingKey
    
}


/**
 * A key that provides the capability to view incoming and outgoing transactions. 
 *  
 * This key is useful anywhere you need to maintain accurate balance, but do not want the 
 * ability to spend funds (such as a view-only wallet). 
 */
class ZcashOrchardFullViewingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardFullViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `addressAt`(`j`: ZcashOrchardDiversifierIndex, `scope`: ZcashOrchardScope): ZcashOrchardAddress =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFullViewingKey_address_at(it, FfiConverterTypeZcashOrchardDiversifierIndex.lower(`j`), FfiConverterTypeZcashOrchardScope.lower(`scope`),  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }
    override fun `address`(`d`: ZcashOrchardDiversifier, `scope`: ZcashOrchardScope): ZcashOrchardAddress =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFullViewingKey_address(it, FfiConverterTypeZcashOrchardDiversifier.lower(`d`), FfiConverterTypeZcashOrchardScope.lower(`scope`),  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }
    override fun `scopeForAddress`(`address`: ZcashOrchardAddress): ZcashOrchardScope? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFullViewingKey_scope_for_address(it, FfiConverterTypeZcashOrchardAddress.lower(`address`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashOrchardScope.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFullViewingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `toIvk`(`scope`: ZcashOrchardScope): ZcashOrchardIncomingViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFullViewingKey_to_ivk(it, FfiConverterTypeZcashOrchardScope.lower(`scope`),  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardIncomingViewingKey.lift(it)
        }
    override fun `toOvk`(`scope`: ZcashOrchardScope): ZcashOrchardOutgoingViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFullViewingKey_to_ovk(it, FfiConverterTypeZcashOrchardScope.lower(`scope`),  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardOutgoingViewingKey.lift(it)
        }
    

    companion object {
        

    /**
     * Parses a full viewing key from its "raw" encoding as specified in [Zcash Protocol Spec § 5.6.4.4: Orchard Raw Full Viewing Keys][orchardrawfullviewingkeys] 
     *  
     * [orchardrawfullviewingkeys]: https://zips.z.cash/protocol/protocol.pdf#orchardfullviewingkeyencoding 
     */
        fun `fromBytes`(`bytes`: List<UByte>): ZcashOrchardFullViewingKey =
            ZcashOrchardFullViewingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardFullViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardFullViewingKey: FfiConverter<ZcashOrchardFullViewingKey, Pointer> {
    override fun lower(value: ZcashOrchardFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardFullViewingKey {
        return ZcashOrchardFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardFullViewingKey) = 8

    override fun write(value: ZcashOrchardFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardIncomingViewingKeyInterface {
    

    /**
     * Serializes an Orchard incoming viewing key to its raw encoding as specified in [Zcash Protocol Spec § 5.6.4.3: Orchard Raw Incoming Viewing Keys][orchardrawinviewingkeys] 
     *  
     * [orchardrawinviewingkeys]: https://zips.z.cash/protocol/protocol.pdf#orchardinviewingkeyencoding 
     */
    fun `toBytes`(): List<UByte>
    

    /**
     * Checks whether the given address was derived from this incoming viewing 
     * key, and returns the diversifier index used to derive the address if 
     * so. Returns `None` if the address was not derived from this key. 
     */
    fun `diversifierIndex`(`addr`: ZcashOrchardAddress): ZcashOrchardDiversifierIndex?
    

    /**
     * Returns the payment address for this key at the given index. 
     */
    fun `addressAt`(`j`: ZcashOrchardDiversifierIndex): ZcashOrchardAddress
    

    /**
     * Returns the payment address for this key corresponding to the given diversifier. 
     */
    fun `address`(`diversifier`: ZcashOrchardDiversifier): ZcashOrchardAddress
    
}


/**
 * A key that provides the capability to detect and decrypt incoming notes from the block 
 * chain, without being able to spend the notes or detect when they are spent. 
 *  
 * This key is useful in situations where you only need the capability to detect inbound 
 * payments, such as merchant terminals. 
 */
class ZcashOrchardIncomingViewingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardIncomingViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardIncomingViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardIncomingViewingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `diversifierIndex`(`addr`: ZcashOrchardAddress): ZcashOrchardDiversifierIndex? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardIncomingViewingKey_diversifier_index(it, FfiConverterTypeZcashOrchardAddress.lower(`addr`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashOrchardDiversifierIndex.lift(it)
        }
    override fun `addressAt`(`j`: ZcashOrchardDiversifierIndex): ZcashOrchardAddress =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardIncomingViewingKey_address_at(it, FfiConverterTypeZcashOrchardDiversifierIndex.lower(`j`),  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }
    override fun `address`(`diversifier`: ZcashOrchardDiversifier): ZcashOrchardAddress =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardIncomingViewingKey_address(it, FfiConverterTypeZcashOrchardDiversifier.lower(`diversifier`),  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }
    

    companion object {
        

    /**
     * Parses an Orchard incoming viewing key from its raw encoding. 
     */
        fun `fromBytes`(`bytes`: List<UByte>): ZcashOrchardIncomingViewingKey =
            ZcashOrchardIncomingViewingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardIncomingViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardIncomingViewingKey: FfiConverter<ZcashOrchardIncomingViewingKey, Pointer> {
    override fun lower(value: ZcashOrchardIncomingViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardIncomingViewingKey {
        return ZcashOrchardIncomingViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardIncomingViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardIncomingViewingKey) = 8

    override fun write(value: ZcashOrchardIncomingViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardMerkleHashInterface {
    

    fun `toBytes`(): List<UByte>
    
}


/**
 * A newtype wrapper for leaves and internal nodes in the Orchard 
 * incremental note commitment tree. 
 */
class ZcashOrchardMerkleHash(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardMerkleHashInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardMerkleHash_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardMerkleHash_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>): ZcashOrchardMerkleHash =
            ZcashOrchardMerkleHash(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardMerkleHash_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        

        fun `fromCmx`(`cmx`: ZcashExtractedNoteCommitment): ZcashOrchardMerkleHash =
            ZcashOrchardMerkleHash(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardMerkleHash_from_cmx(FfiConverterTypeZcashExtractedNoteCommitment.lower(`cmx`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardMerkleHash: FfiConverter<ZcashOrchardMerkleHash, Pointer> {
    override fun lower(value: ZcashOrchardMerkleHash): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardMerkleHash {
        return ZcashOrchardMerkleHash(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardMerkleHash {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardMerkleHash) = 8

    override fun write(value: ZcashOrchardMerkleHash, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardMerklePathInterface {
    

    /**
     * <https://zips.z.cash/protocol/protocol.pdf#orchardmerklecrh> 
     * The layer with 2^n nodes is called "layer n": 
     * - leaves are at layer MERKLE_DEPTH_ORCHARD = 32; 
     * - the root is at layer 0. 
     * `l` is MERKLE_DEPTH_ORCHARD - layer - 1. 
     * - when hashing two leaves, we produce a node on the layer above the leaves, i.e. 
     * layer = 31, l = 0 
     * - when hashing to the final root, we produce the anchor with layer = 0, l = 31. 
     */
    fun `root`(`cmx`: ZcashExtractedNoteCommitment): ZcashAnchor
    
}


/**
 * The Merkle path from a leaf of the note commitment tree 
 * to its anchor. 
 */
class ZcashOrchardMerklePath(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardMerklePathInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardMerklePath_object_free(this.pointer, status)
        }
    }

    override fun `root`(`cmx`: ZcashExtractedNoteCommitment): ZcashAnchor =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardMerklePath_root(it, FfiConverterTypeZcashExtractedNoteCommitment.lower(`cmx`),  _status)
}
        }.let {
            FfiConverterTypeZcashAnchor.lift(it)
        }
    

    companion object {
        

    /**
     * Instantiates a new Merkle path given a leaf position and authentication path. 
     */
        fun `fromParts`(`position`: UInt, `authPath`: List<ZcashOrchardMerkleHash>): ZcashOrchardMerklePath =
            ZcashOrchardMerklePath(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardMerklePath_from_parts(FfiConverterUInt.lower(`position`), FfiConverterSequenceTypeZcashOrchardMerkleHash.lower(`authPath`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardMerklePath: FfiConverter<ZcashOrchardMerklePath, Pointer> {
    override fun lower(value: ZcashOrchardMerklePath): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardMerklePath {
        return ZcashOrchardMerklePath(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardMerklePath {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardMerklePath) = 8

    override fun write(value: ZcashOrchardMerklePath, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardNoteInterface {
    

    fun `recipient`(): ZcashOrchardAddress
    

    fun `value`(): ZcashOrchardNoteValue
    

    /**
     * Derives the commitment to this note. 
     *  
     * Defined in [Zcash Protocol Spec § 3.2: Notes][notes]. 
     *  
     * [notes]: https://zips.z.cash/protocol/nu5.pdf#notes 
     */
    fun `commitment`(): ZcashOrchardNoteCommitment
    
}


/**
 * A discrete amount of funds received by an address. 
 */
class ZcashOrchardNote(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardNoteInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardNote_object_free(this.pointer, status)
        }
    }

    override fun `recipient`(): ZcashOrchardAddress =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardNote_recipient(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }
    override fun `value`(): ZcashOrchardNoteValue =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardNote_value(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardNoteValue.lift(it)
        }
    override fun `commitment`(): ZcashOrchardNoteCommitment =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardNote_commitment(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardNoteCommitment.lift(it)
        }
    

    companion object {
        

    /**
     * Creates a `Note` from its component parts. 
     *  
     * This low-level constructor enforces that the provided arguments produce an 
     * internally valid `Note`. However, it allows notes to be constructed in a way that 
     * violates required security checks for note decryption, as specified in 
     * [Section 4.19] of the Zcash Protocol Specification. Users of this constructor 
     * should only call it with note components that have been fully validated by 
     * decrypting a received note according to [Section 4.19]. 
     *  
     * [Section 4.19]: https://zips.z.cash/protocol/protocol.pdf#saplingandorchardinband 
     */
        fun `fromParts`(`recipient`: ZcashOrchardAddress, `value`: ZcashOrchardNoteValue, `rho`: ZcashOrchardNullifier, `rseed`: ZcashOrchardRandomSeed): ZcashOrchardNote =
            ZcashOrchardNote(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardNote_from_parts(FfiConverterTypeZcashOrchardAddress.lower(`recipient`), FfiConverterTypeZcashOrchardNoteValue.lower(`value`), FfiConverterTypeZcashOrchardNullifier.lower(`rho`), FfiConverterTypeZcashOrchardRandomSeed.lower(`rseed`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardNote: FfiConverter<ZcashOrchardNote, Pointer> {
    override fun lower(value: ZcashOrchardNote): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardNote {
        return ZcashOrchardNote(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardNote {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardNote) = 8

    override fun write(value: ZcashOrchardNote, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardNoteCommitmentInterface {
    

    fun `toExtractedNoteCommitment`(): ZcashExtractedNoteCommitment
    
}


class ZcashOrchardNoteCommitment(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardNoteCommitmentInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardNoteCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toExtractedNoteCommitment`(): ZcashExtractedNoteCommitment =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardNoteCommitment_to_extracted_note_commitment(it,  _status)
}
        }.let {
            FfiConverterTypeZcashExtractedNoteCommitment.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashOrchardNoteCommitment: FfiConverter<ZcashOrchardNoteCommitment, Pointer> {
    override fun lower(value: ZcashOrchardNoteCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardNoteCommitment {
        return ZcashOrchardNoteCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardNoteCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardNoteCommitment) = 8

    override fun write(value: ZcashOrchardNoteCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardNoteValueInterface {
    

    /**
     * Returns the raw underlying value. 
     */
    fun `value`(): ULong
    
}


/**
 * The non-negative value of an individual Orchard note. 
 */
class ZcashOrchardNoteValue(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardNoteValueInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardNoteValue_object_free(this.pointer, status)
        }
    }

    override fun `value`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardNoteValue_value(it,  _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    

    companion object {
        

    /**
     * Creates a note value from its raw numeric value. 
     *  
     * This only enforces that the value is an unsigned 64-bit integer. Callers should 
     * enforce any additional constraints on the value's valid range themselves. 
     */
        fun `fromRaw`(`value`: ULong): ZcashOrchardNoteValue =
            ZcashOrchardNoteValue(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardNoteValue_from_raw(FfiConverterULong.lower(`value`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardNoteValue: FfiConverter<ZcashOrchardNoteValue, Pointer> {
    override fun lower(value: ZcashOrchardNoteValue): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardNoteValue {
        return ZcashOrchardNoteValue(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardNoteValue {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardNoteValue) = 8

    override fun write(value: ZcashOrchardNoteValue, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardNullifierInterface {
    

    /**
     * Serialize the nullifier to its canonical byte representation. 
     */
    fun `toBytes`(): List<UByte>
    
}


/**
 * A unique nullifier for a note. 
 */
class ZcashOrchardNullifier(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardNullifierInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardNullifier_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardNullifier_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

    /**
     * Deserialize the nullifier from a byte array. 
     */
        fun `fromBytes`(`data`: List<UByte>): ZcashOrchardNullifier =
            ZcashOrchardNullifier(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardNullifier_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardNullifier: FfiConverter<ZcashOrchardNullifier, Pointer> {
    override fun lower(value: ZcashOrchardNullifier): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardNullifier {
        return ZcashOrchardNullifier(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardNullifier {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardNullifier) = 8

    override fun write(value: ZcashOrchardNullifier, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardOutgoingViewingKeyInterface {
    

    fun `toBytes`(): List<UByte>
    
}


/**
 * A key that provides the capability to recover outgoing transaction information from 
 * the block chain. 
 */
class ZcashOrchardOutgoingViewingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardOutgoingViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardOutgoingViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardOutgoingViewingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`bytes`: List<UByte>): ZcashOrchardOutgoingViewingKey =
            ZcashOrchardOutgoingViewingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardOutgoingViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardOutgoingViewingKey: FfiConverter<ZcashOrchardOutgoingViewingKey, Pointer> {
    override fun lower(value: ZcashOrchardOutgoingViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardOutgoingViewingKey {
        return ZcashOrchardOutgoingViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardOutgoingViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardOutgoingViewingKey) = 8

    override fun write(value: ZcashOrchardOutgoingViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardRandomSeedInterface {
    

    /**
     * Returns the byte array corresponding to this seed. 
     */
    fun `toBytes`(): List<UByte>
    
}


/**
 * The ZIP 212 seed randomness for a note. 
 */
class ZcashOrchardRandomSeed(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardRandomSeedInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardRandomSeed_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardRandomSeed_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

    /**
     * Reads a note's random seed from bytes, given the note's nullifier. 
     *  
     * Returns `None` if the nullifier is not for the same note as the seed. 
     */
        fun `fromBytes`(`data`: List<UByte>, `rho`: ZcashOrchardNullifier): ZcashOrchardRandomSeed =
            ZcashOrchardRandomSeed(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardRandomSeed_from_bytes(FfiConverterSequenceUByte.lower(`data`), FfiConverterTypeZcashOrchardNullifier.lower(`rho`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardRandomSeed: FfiConverter<ZcashOrchardRandomSeed, Pointer> {
    override fun lower(value: ZcashOrchardRandomSeed): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardRandomSeed {
        return ZcashOrchardRandomSeed(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardRandomSeed {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardRandomSeed) = 8

    override fun write(value: ZcashOrchardRandomSeed, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardSpendingKeyInterface {
    

    fun `toBytes`(): List<UByte>
    

    fun `toFvk`(): ZcashOrchardFullViewingKey
    
}


class ZcashOrchardSpendingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardSpendingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardSpendingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardSpendingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `toFvk`(): ZcashOrchardFullViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardSpendingKey_to_fvk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardFullViewingKey.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>): ZcashOrchardSpendingKey =
            ZcashOrchardSpendingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardSpendingKey_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        

        fun `fromZip32Seed`(`seed`: List<UByte>, `coinType`: UInt, `account`: UInt): ZcashOrchardSpendingKey =
            ZcashOrchardSpendingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardSpendingKey_from_zip32_seed(FfiConverterSequenceUByte.lower(`seed`), FfiConverterUInt.lower(`coinType`), FfiConverterUInt.lower(`account`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOrchardSpendingKey: FfiConverter<ZcashOrchardSpendingKey, Pointer> {
    override fun lower(value: ZcashOrchardSpendingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardSpendingKey {
        return ZcashOrchardSpendingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardSpendingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardSpendingKey) = 8

    override fun write(value: ZcashOrchardSpendingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardTransactionBuilderInterface {
    

    fun `addSpend`(`fvk`: ZcashOrchardFullViewingKey, `note`: ZcashOrchardNote, `merklePath`: ZcashOrchardMerklePath)
    

    @Throws(ZcashException::class)
    fun `addRecipient`(`ovk`: ZcashOrchardOutgoingViewingKey?, `recipient`: ZcashOrchardAddress, `value`: ZcashOrchardNoteValue, `memo`: List<UByte>?)
    

    @Throws(ZcashException::class)
    fun `build`(`keys`: List<ZcashOrchardSpendingKey>, `sighash`: List<UByte>): ZcashTransaction
    
}


class ZcashOrchardTransactionBuilder(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardTransactionBuilderInterface {

    constructor(`parameters`: ZcashConsensusParameters, `targetHeight`: ZcashBlockHeight, `expiryHeight`: ZcashBlockHeight, `anchor`: ZcashAnchor, `flags`: ZcashOrchardFlags) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardTransactionBuilder_new(FfiConverterTypeZcashConsensusParameters.lower(`parameters`), FfiConverterTypeZcashBlockHeight.lower(`targetHeight`), FfiConverterTypeZcashBlockHeight.lower(`expiryHeight`), FfiConverterTypeZcashAnchor.lower(`anchor`), FfiConverterTypeZcashOrchardFlags.lower(`flags`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardTransactionBuilder_object_free(this.pointer, status)
        }
    }

    override fun `addSpend`(`fvk`: ZcashOrchardFullViewingKey, `note`: ZcashOrchardNote, `merklePath`: ZcashOrchardMerklePath) =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardTransactionBuilder_add_spend(it, FfiConverterTypeZcashOrchardFullViewingKey.lower(`fvk`), FfiConverterTypeZcashOrchardNote.lower(`note`), FfiConverterTypeZcashOrchardMerklePath.lower(`merklePath`),  _status)
}
        }
    
    
    @Throws(ZcashException::class)override fun `addRecipient`(`ovk`: ZcashOrchardOutgoingViewingKey?, `recipient`: ZcashOrchardAddress, `value`: ZcashOrchardNoteValue, `memo`: List<UByte>?) =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardTransactionBuilder_add_recipient(it, FfiConverterOptionalTypeZcashOrchardOutgoingViewingKey.lower(`ovk`), FfiConverterTypeZcashOrchardAddress.lower(`recipient`), FfiConverterTypeZcashOrchardNoteValue.lower(`value`), FfiConverterOptionalSequenceUByte.lower(`memo`),  _status)
}
        }
    
    
    @Throws(ZcashException::class)override fun `build`(`keys`: List<ZcashOrchardSpendingKey>, `sighash`: List<UByte>): ZcashTransaction =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardTransactionBuilder_build(it, FfiConverterSequenceTypeZcashOrchardSpendingKey.lower(`keys`), FfiConverterSequenceUByte.lower(`sighash`),  _status)
}
        }.let {
            FfiConverterTypeZcashTransaction.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashOrchardTransactionBuilder: FfiConverter<ZcashOrchardTransactionBuilder, Pointer> {
    override fun lower(value: ZcashOrchardTransactionBuilder): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardTransactionBuilder {
        return ZcashOrchardTransactionBuilder(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardTransactionBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardTransactionBuilder) = 8

    override fun write(value: ZcashOrchardTransactionBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOrchardValueCommitmentInterface {
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashOrchardValueCommitment(
    pointer: Pointer
) : FFIObject(pointer), ZcashOrchardValueCommitmentInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOrchardValueCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOrchardValueCommitment_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashOrchardValueCommitment: FfiConverter<ZcashOrchardValueCommitment, Pointer> {
    override fun lower(value: ZcashOrchardValueCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardValueCommitment {
        return ZcashOrchardValueCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardValueCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardValueCommitment) = 8

    override fun write(value: ZcashOrchardValueCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOutPointInterface {
    
}


class ZcashOutPoint(
    pointer: Pointer
) : FFIObject(pointer), ZcashOutPointInterface {

    constructor(`hash`: List<UByte>, `n`: UInt) :
        this(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOutPoint_new(FfiConverterSequenceUByte.lower(`hash`), FfiConverterUInt.lower(`n`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOutPoint_object_free(this.pointer, status)
        }
    }

    

    
}

public object FfiConverterTypeZcashOutPoint: FfiConverter<ZcashOutPoint, Pointer> {
    override fun lower(value: ZcashOutPoint): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOutPoint {
        return ZcashOutPoint(value)
    }

    override fun read(buf: ByteBuffer): ZcashOutPoint {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOutPoint) = 8

    override fun write(value: ZcashOutPoint, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashOutgoingViewingKeyInterface {
    

    fun `toBytes`(): List<UByte>
    
}


/**
 * An outgoing viewing key 
 */
class ZcashOutgoingViewingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashOutgoingViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashOutgoingViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOutgoingViewingKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`b`: List<UByte>): ZcashOutgoingViewingKey =
            ZcashOutgoingViewingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashOutgoingViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`b`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashOutgoingViewingKey: FfiConverter<ZcashOutgoingViewingKey, Pointer> {
    override fun lower(value: ZcashOutgoingViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOutgoingViewingKey {
        return ZcashOutgoingViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOutgoingViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOutgoingViewingKey) = 8

    override fun write(value: ZcashOutgoingViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashPaymentAddressInterface {
    

    /**
     * Encode payment address into string 
     */
    fun `encode`(`params`: ZcashConsensusParameters): String
    

    /**
     * Returns the byte encoding of this `PaymentAddress`. 
     */
    fun `toBytes`(): List<UByte>
    

    /**
     * Returns the [`Diversifier`] for this `PaymentAddress`. 
     */
    fun `diversifier`(): ZcashDiversifier
    

    /**
     * Returns `pk_d` for this `PaymentAddress`. 
     */
    fun `pkD`(): ZcashSaplingDiversifiedTransmissionKey
    

    @Throws(ZcashException::class)
    fun `createNote`(`value`: ULong, `rseed`: ZcashRseed): ZcashSaplingNote
    
}


/**
 * A Sapling payment address. 
 *  
 * # Invariants 
 *  
 * `pk_d` is guaranteed to be prime-order (i.e. in the prime-order subgroup of Jubjub, 
 * and not the identity). 
 */
class ZcashPaymentAddress(
    pointer: Pointer
) : FFIObject(pointer), ZcashPaymentAddressInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashPaymentAddress_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashPaymentAddress_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashPaymentAddress_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `diversifier`(): ZcashDiversifier =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashPaymentAddress_diversifier(it,  _status)
}
        }.let {
            FfiConverterTypeZcashDiversifier.lift(it)
        }
    override fun `pkD`(): ZcashSaplingDiversifiedTransmissionKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashPaymentAddress_pk_d(it,  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingDiversifiedTransmissionKey.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `createNote`(`value`: ULong, `rseed`: ZcashRseed): ZcashSaplingNote =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashPaymentAddress_create_note(it, FfiConverterULong.lower(`value`), FfiConverterTypeZcashRseed.lower(`rseed`),  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingNote.lift(it)
        }
    

    companion object {
        

    /**
     * Parses a PaymentAddress from bytes. 
     */
        fun `fromBytes`(`bytes`: List<UByte>): ZcashPaymentAddress =
            ZcashPaymentAddress(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashPaymentAddress_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
})
        

    /**
     * Decodes a [`PaymentAddress`] from a Bech32-encoded string. 
     */
        fun `decode`(`params`: ZcashConsensusParameters, `input`: String): ZcashPaymentAddress =
            ZcashPaymentAddress(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashPaymentAddress_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`input`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashPaymentAddress: FfiConverter<ZcashPaymentAddress, Pointer> {
    override fun lower(value: ZcashPaymentAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashPaymentAddress {
        return ZcashPaymentAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashPaymentAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashPaymentAddress) = 8

    override fun write(value: ZcashPaymentAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashProofGenerationKeyInterface {
    

    fun `toViewingKey`(): ZcashViewingKey
    
}


class ZcashProofGenerationKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashProofGenerationKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashProofGenerationKey_object_free(this.pointer, status)
        }
    }

    override fun `toViewingKey`(): ZcashViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashProofGenerationKey_to_viewing_key(it,  _status)
}
        }.let {
            FfiConverterTypeZcashViewingKey.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashProofGenerationKey: FfiConverter<ZcashProofGenerationKey, Pointer> {
    override fun lower(value: ZcashProofGenerationKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashProofGenerationKey {
        return ZcashProofGenerationKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashProofGenerationKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashProofGenerationKey) = 8

    override fun write(value: ZcashProofGenerationKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashProvingKeyInterface {
    
}


/**
 * The proving key for the Orchard Action circuit. 
 */
class ZcashProvingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashProvingKeyInterface {

    /**
     * Builds the verifying key. 
     */
    constructor() :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashProvingKey_new( _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashProvingKey_object_free(this.pointer, status)
        }
    }

    

    
}

public object FfiConverterTypeZcashProvingKey: FfiConverter<ZcashProvingKey, Pointer> {
    override fun lower(value: ZcashProvingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashProvingKey {
        return ZcashProvingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashProvingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashProvingKey) = 8

    override fun write(value: ZcashProvingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashRecipientAddressInterface {
    

    fun `encode`(`params`: ZcashConsensusParameters): String
    
}


/**
 * An address that funds can be sent to. 
 */
class ZcashRecipientAddress(
    pointer: Pointer
) : FFIObject(pointer), ZcashRecipientAddressInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashRecipientAddress_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashRecipientAddress_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    

    companion object {
        

        fun `decode`(`params`: ZcashConsensusParameters, `address`: String): ZcashRecipientAddress =
            ZcashRecipientAddress(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashRecipientAddress_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`address`), _status)
})
        

        fun `shielded`(`addr`: ZcashPaymentAddress): ZcashRecipientAddress =
            ZcashRecipientAddress(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashRecipientAddress_shielded(FfiConverterTypeZcashPaymentAddress.lower(`addr`), _status)
})
        

        fun `transparent`(`addr`: ZcashTransparentAddress): ZcashRecipientAddress =
            ZcashRecipientAddress(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashRecipientAddress_transparent(FfiConverterTypeZcashTransparentAddress.lower(`addr`), _status)
})
        

        fun `unified`(`addr`: ZcashUnifiedAddress): ZcashRecipientAddress =
            ZcashRecipientAddress(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashRecipientAddress_unified(FfiConverterTypeZcashUnifiedAddress.lower(`addr`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashRecipientAddress: FfiConverter<ZcashRecipientAddress, Pointer> {
    override fun lower(value: ZcashRecipientAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashRecipientAddress {
        return ZcashRecipientAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashRecipientAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashRecipientAddress) = 8

    override fun write(value: ZcashRecipientAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingBundleInterface {
    

    fun `shieldedSpends`(): List<ZcashSaplingSpendDescription>
    

    fun `shieldedOutputs`(): List<ZcashSaplingOutputDescription>
    

    fun `valueBalance`(): ZcashAmount
    
}


class ZcashSaplingBundle(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingBundleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingBundle_object_free(this.pointer, status)
        }
    }

    override fun `shieldedSpends`(): List<ZcashSaplingSpendDescription> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingBundle_shielded_spends(it,  _status)
}
        }.let {
            FfiConverterSequenceTypeZcashSaplingSpendDescription.lift(it)
        }
    override fun `shieldedOutputs`(): List<ZcashSaplingOutputDescription> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingBundle_shielded_outputs(it,  _status)
}
        }.let {
            FfiConverterSequenceTypeZcashSaplingOutputDescription.lift(it)
        }
    override fun `valueBalance`(): ZcashAmount =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingBundle_value_balance(it,  _status)
}
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingBundle: FfiConverter<ZcashSaplingBundle, Pointer> {
    override fun lower(value: ZcashSaplingBundle): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingBundle {
        return ZcashSaplingBundle(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingBundle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingBundle) = 8

    override fun write(value: ZcashSaplingBundle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingDiversifiedTransmissionKeyInterface {
    
}


class ZcashSaplingDiversifiedTransmissionKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingDiversifiedTransmissionKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingDiversifiedTransmissionKey_object_free(this.pointer, status)
        }
    }

    

    
}

public object FfiConverterTypeZcashSaplingDiversifiedTransmissionKey: FfiConverter<ZcashSaplingDiversifiedTransmissionKey, Pointer> {
    override fun lower(value: ZcashSaplingDiversifiedTransmissionKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingDiversifiedTransmissionKey {
        return ZcashSaplingDiversifiedTransmissionKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingDiversifiedTransmissionKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingDiversifiedTransmissionKey) = 8

    override fun write(value: ZcashSaplingDiversifiedTransmissionKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingExtractedNoteCommitmentInterface {
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashSaplingExtractedNoteCommitment(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingExtractedNoteCommitmentInterface {

    constructor(`data`: List<UByte>) :
        this(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingExtractedNoteCommitment_new(FfiConverterSequenceUByte.lower(`data`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingExtractedNoteCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingExtractedNoteCommitment_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingExtractedNoteCommitment: FfiConverter<ZcashSaplingExtractedNoteCommitment, Pointer> {
    override fun lower(value: ZcashSaplingExtractedNoteCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingExtractedNoteCommitment {
        return ZcashSaplingExtractedNoteCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingExtractedNoteCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingExtractedNoteCommitment) = 8

    override fun write(value: ZcashSaplingExtractedNoteCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingIvkInterface {
    

    fun `toPaymentAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress?
    

    fun `toRepr`(): List<UByte>
    
}


class ZcashSaplingIvk(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingIvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingIvk_object_free(this.pointer, status)
        }
    }

    override fun `toPaymentAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingIvk_to_payment_address(it, FfiConverterTypeZcashDiversifier.lower(`diversifier`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `toRepr`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingIvk_to_repr(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingIvk: FfiConverter<ZcashSaplingIvk, Pointer> {
    override fun lower(value: ZcashSaplingIvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingIvk {
        return ZcashSaplingIvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingIvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingIvk) = 8

    override fun write(value: ZcashSaplingIvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingMerklePathInterface {
    

    fun `authPath`(): List<ZcashAuthPath>
    

    fun `position`(): ULong
    
}


class ZcashSaplingMerklePath(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingMerklePathInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingMerklePath_object_free(this.pointer, status)
        }
    }

    override fun `authPath`(): List<ZcashAuthPath> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingMerklePath_auth_path(it,  _status)
}
        }.let {
            FfiConverterSequenceTypeZcashAuthPath.lift(it)
        }
    override fun `position`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingMerklePath_position(it,  _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingMerklePath: FfiConverter<ZcashSaplingMerklePath, Pointer> {
    override fun lower(value: ZcashSaplingMerklePath): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingMerklePath {
        return ZcashSaplingMerklePath(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingMerklePath {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingMerklePath) = 8

    override fun write(value: ZcashSaplingMerklePath, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingMetadataInterface {
    

    /**
     * Returns the index within the transaction of the [`SpendDescription`] corresponding 
     * to the `n`-th call to [`SaplingBuilder::add_spend`]. 
     *  
     * Note positions are randomized when building transactions for indistinguishability. 
     * This means that the transaction consumer cannot assume that e.g. the first spend 
     * they added (via the first call to [`SaplingBuilder::add_spend`]) is the first 
     */
    fun `spendIndex`(`n`: ULong): ULong?
    

    /**
     * Returns the index within the transaction of the [`OutputDescription`] corresponding 
     * to the `n`-th call to [`SaplingBuilder::add_output`]. 
     *  
     * Note positions are randomized when building transactions for indistinguishability. 
     * This means that the transaction consumer cannot assume that e.g. the first output 
     * they added (via the first call to [`SaplingBuilder::add_output`]) is the first 
     * [`OutputDescription`] in the transaction. 
     */
    fun `outputIndex`(`n`: ULong): ULong?
    
}


/**
 * Metadata about a transaction created by a [`SaplingBuilder`]. 
 */
class ZcashSaplingMetadata(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingMetadataInterface {

    constructor() :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingMetadata_new( _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingMetadata_object_free(this.pointer, status)
        }
    }

    override fun `spendIndex`(`n`: ULong): ULong? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingMetadata_spend_index(it, FfiConverterULong.lower(`n`),  _status)
}
        }.let {
            FfiConverterOptionalULong.lift(it)
        }
    override fun `outputIndex`(`n`: ULong): ULong? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingMetadata_output_index(it, FfiConverterULong.lower(`n`),  _status)
}
        }.let {
            FfiConverterOptionalULong.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingMetadata: FfiConverter<ZcashSaplingMetadata, Pointer> {
    override fun lower(value: ZcashSaplingMetadata): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingMetadata {
        return ZcashSaplingMetadata(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingMetadata {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingMetadata) = 8

    override fun write(value: ZcashSaplingMetadata, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingNodeInterface {
    
}


class ZcashSaplingNode(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingNodeInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingNode_object_free(this.pointer, status)
        }
    }

    

    companion object {
        

        fun `fromCmu`(`cmu`: ZcashSaplingExtractedNoteCommitment): ZcashSaplingNode =
            ZcashSaplingNode(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingNode_from_cmu(FfiConverterTypeZcashSaplingExtractedNoteCommitment.lower(`cmu`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashSaplingNode: FfiConverter<ZcashSaplingNode, Pointer> {
    override fun lower(value: ZcashSaplingNode): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingNode {
        return ZcashSaplingNode(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingNode {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingNode) = 8

    override fun write(value: ZcashSaplingNode, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingNoteInterface {
    

    fun `value`(): ZcashSaplingNoteValue
    

    fun `cmu`(): ZcashSaplingExtractedNoteCommitment
    
}


class ZcashSaplingNote(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingNoteInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingNote_object_free(this.pointer, status)
        }
    }

    override fun `value`(): ZcashSaplingNoteValue =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingNote_value(it,  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingNoteValue.lift(it)
        }
    override fun `cmu`(): ZcashSaplingExtractedNoteCommitment =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingNote_cmu(it,  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(it)
        }
    

    companion object {
        

        fun `fromParts`(`recipient`: ZcashPaymentAddress, `value`: ZcashSaplingNoteValue, `rseed`: ZcashRseed): ZcashSaplingNote =
            ZcashSaplingNote(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingNote_from_parts(FfiConverterTypeZcashPaymentAddress.lower(`recipient`), FfiConverterTypeZcashSaplingNoteValue.lower(`value`), FfiConverterTypeZcashRseed.lower(`rseed`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashSaplingNote: FfiConverter<ZcashSaplingNote, Pointer> {
    override fun lower(value: ZcashSaplingNote): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingNote {
        return ZcashSaplingNote(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingNote {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingNote) = 8

    override fun write(value: ZcashSaplingNote, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingNoteValueInterface {
    

    fun `inner`(): ULong
    
}


class ZcashSaplingNoteValue(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingNoteValueInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingNoteValue_object_free(this.pointer, status)
        }
    }

    override fun `inner`(): ULong =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingNoteValue_inner(it,  _status)
}
        }.let {
            FfiConverterULong.lift(it)
        }
    

    companion object {
        

        fun `fromRaw`(`data`: ULong): ZcashSaplingNoteValue =
            ZcashSaplingNoteValue(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingNoteValue_from_raw(FfiConverterULong.lower(`data`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashSaplingNoteValue: FfiConverter<ZcashSaplingNoteValue, Pointer> {
    override fun lower(value: ZcashSaplingNoteValue): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingNoteValue {
        return ZcashSaplingNoteValue(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingNoteValue {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingNoteValue) = 8

    override fun write(value: ZcashSaplingNoteValue, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingNullifierInterface {
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashSaplingNullifier(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingNullifierInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingNullifier_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingNullifier_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingNullifier: FfiConverter<ZcashSaplingNullifier, Pointer> {
    override fun lower(value: ZcashSaplingNullifier): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingNullifier {
        return ZcashSaplingNullifier(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingNullifier {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingNullifier) = 8

    override fun write(value: ZcashSaplingNullifier, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingOutputDescriptionInterface {
    

    fun `cv`(): ZcashSaplingValueCommitment
    

    fun `cmu`(): ZcashSaplingExtractedNoteCommitment
    
}


class ZcashSaplingOutputDescription(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingOutputDescriptionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingOutputDescription_object_free(this.pointer, status)
        }
    }

    override fun `cv`(): ZcashSaplingValueCommitment =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingOutputDescription_cv(it,  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingValueCommitment.lift(it)
        }
    override fun `cmu`(): ZcashSaplingExtractedNoteCommitment =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingOutputDescription_cmu(it,  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingOutputDescription: FfiConverter<ZcashSaplingOutputDescription, Pointer> {
    override fun lower(value: ZcashSaplingOutputDescription): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingOutputDescription {
        return ZcashSaplingOutputDescription(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingOutputDescription {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingOutputDescription) = 8

    override fun write(value: ZcashSaplingOutputDescription, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingPublicKeyInterface {
    

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
    
}


class ZcashSaplingPublicKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingPublicKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingPublicKey_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingPublicKey_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingPublicKey: FfiConverter<ZcashSaplingPublicKey, Pointer> {
    override fun lower(value: ZcashSaplingPublicKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingPublicKey {
        return ZcashSaplingPublicKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingPublicKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingPublicKey) = 8

    override fun write(value: ZcashSaplingPublicKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingSpendDescriptionInterface {
    

    fun `cv`(): ZcashSaplingValueCommitment
    

    fun `anchor`(): List<UByte>
    

    fun `nullifier`(): ZcashSaplingNullifier
    

    fun `rk`(): ZcashSaplingPublicKey
    
}


class ZcashSaplingSpendDescription(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingSpendDescriptionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingSpendDescription_object_free(this.pointer, status)
        }
    }

    override fun `cv`(): ZcashSaplingValueCommitment =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingSpendDescription_cv(it,  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingValueCommitment.lift(it)
        }
    override fun `anchor`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingSpendDescription_anchor(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `nullifier`(): ZcashSaplingNullifier =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingSpendDescription_nullifier(it,  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingNullifier.lift(it)
        }
    override fun `rk`(): ZcashSaplingPublicKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingSpendDescription_rk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingPublicKey.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingSpendDescription: FfiConverter<ZcashSaplingSpendDescription, Pointer> {
    override fun lower(value: ZcashSaplingSpendDescription): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingSpendDescription {
        return ZcashSaplingSpendDescription(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingSpendDescription {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingSpendDescription) = 8

    override fun write(value: ZcashSaplingSpendDescription, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashSaplingValueCommitmentInterface {
    

    fun `toBytes`(): List<UByte>
    
}


class ZcashSaplingValueCommitment(
    pointer: Pointer
) : FFIObject(pointer), ZcashSaplingValueCommitmentInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashSaplingValueCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashSaplingValueCommitment_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashSaplingValueCommitment: FfiConverter<ZcashSaplingValueCommitment, Pointer> {
    override fun lower(value: ZcashSaplingValueCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingValueCommitment {
        return ZcashSaplingValueCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingValueCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingValueCommitment) = 8

    override fun write(value: ZcashSaplingValueCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashScriptInterface {
    

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
    
}


class ZcashScript(
    pointer: Pointer
) : FFIObject(pointer), ZcashScriptInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashScript_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashScript_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>): ZcashScript =
            ZcashScript(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashScript_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashScript: FfiConverter<ZcashScript, Pointer> {
    override fun lower(value: ZcashScript): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashScript {
        return ZcashScript(value)
    }

    override fun read(buf: ByteBuffer): ZcashScript {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashScript) = 8

    override fun write(value: ZcashScript, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashTransactionInterface {
    

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
    

    fun `txid`(): ZcashTxId
    

    fun `version`(): ZcashTxVersion
    

    fun `consensusBranchId`(): ZcashBranchId
    

    fun `lockTime`(): UInt
    

    fun `expiryHeight`(): ZcashBlockHeight
    

    /**
     * Returns the total fees paid by the transaction, given a function that can be used to 
     * retrieve the value of previous transactions' transparent outputs that are being spent in 
     * this transaction. 
     */
    fun `transparentBundle`(): ZcashTransparentBundle?
    

    fun `saplingBundle`(): ZcashSaplingBundle?
    

    fun `orchardBundle`(): ZcashOrchardBundle?
    
}


/**
 * A Zcash transaction. 
 */
class ZcashTransaction(
    pointer: Pointer
) : FFIObject(pointer), ZcashTransactionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashTransaction_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `txid`(): ZcashTxId =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_txid(it,  _status)
}
        }.let {
            FfiConverterTypeZcashTxId.lift(it)
        }
    override fun `version`(): ZcashTxVersion =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_version(it,  _status)
}
        }.let {
            FfiConverterTypeZcashTxVersion.lift(it)
        }
    override fun `consensusBranchId`(): ZcashBranchId =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_consensus_branch_id(it,  _status)
}
        }.let {
            FfiConverterTypeZcashBranchId.lift(it)
        }
    override fun `lockTime`(): UInt =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_lock_time(it,  _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `expiryHeight`(): ZcashBlockHeight =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_expiry_height(it,  _status)
}
        }.let {
            FfiConverterTypeZcashBlockHeight.lift(it)
        }
    override fun `transparentBundle`(): ZcashTransparentBundle? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_transparent_bundle(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashTransparentBundle.lift(it)
        }
    override fun `saplingBundle`(): ZcashSaplingBundle? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_sapling_bundle(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashSaplingBundle.lift(it)
        }
    override fun `orchardBundle`(): ZcashOrchardBundle? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_orchard_bundle(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashOrchardBundle.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>, `consensusBranchId`: ZcashBranchId): ZcashTransaction =
            ZcashTransaction(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransaction_from_bytes(FfiConverterSequenceUByte.lower(`data`), FfiConverterTypeZcashBranchId.lower(`consensusBranchId`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashTransaction: FfiConverter<ZcashTransaction, Pointer> {
    override fun lower(value: ZcashTransaction): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTransaction {
        return ZcashTransaction(value)
    }

    override fun read(buf: ByteBuffer): ZcashTransaction {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTransaction) = 8

    override fun write(value: ZcashTransaction, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashTransactionBuilderInterface {
    

    fun `addSaplingSpend`(`extsk`: ZcashExtendedSpendingKey, `diversifier`: ZcashDiversifier, `note`: ZcashSaplingNote, `merklePath`: ZcashSaplingMerklePath)
    

    fun `addSaplingOutput`(`ovk`: ZcashOutgoingViewingKey?, `to`: ZcashPaymentAddress, `value`: ZcashAmount, `memo`: ZcashMemoBytes)
    

    fun `addTransparentInput`(`sk`: SecpSecretKey, `utxo`: ZcashOutPoint, `coin`: ZcashTxOut)
    

    fun `addTransparentOutput`(`to`: ZcashTransparentAddress, `value`: ZcashAmount)
    

    @Throws(ZcashException::class)
    fun `build`(`prover`: ZcashLocalTxProver, `feeRule`: ZcashFeeRules): ZcashTransactionAndSaplingMetadata
    
}


class ZcashTransactionBuilder(
    pointer: Pointer
) : FFIObject(pointer), ZcashTransactionBuilderInterface {

    constructor(`parameters`: ZcashConsensusParameters, `blockHeight`: ZcashBlockHeight) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransactionBuilder_new(FfiConverterTypeZcashConsensusParameters.lower(`parameters`), FfiConverterTypeZcashBlockHeight.lower(`blockHeight`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashTransactionBuilder_object_free(this.pointer, status)
        }
    }

    override fun `addSaplingSpend`(`extsk`: ZcashExtendedSpendingKey, `diversifier`: ZcashDiversifier, `note`: ZcashSaplingNote, `merklePath`: ZcashSaplingMerklePath) =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransactionBuilder_add_sapling_spend(it, FfiConverterTypeZcashExtendedSpendingKey.lower(`extsk`), FfiConverterTypeZcashDiversifier.lower(`diversifier`), FfiConverterTypeZcashSaplingNote.lower(`note`), FfiConverterTypeZcashSaplingMerklePath.lower(`merklePath`),  _status)
}
        }
    
    override fun `addSaplingOutput`(`ovk`: ZcashOutgoingViewingKey?, `to`: ZcashPaymentAddress, `value`: ZcashAmount, `memo`: ZcashMemoBytes) =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransactionBuilder_add_sapling_output(it, FfiConverterOptionalTypeZcashOutgoingViewingKey.lower(`ovk`), FfiConverterTypeZcashPaymentAddress.lower(`to`), FfiConverterTypeZcashAmount.lower(`value`), FfiConverterTypeZcashMemoBytes.lower(`memo`),  _status)
}
        }
    
    override fun `addTransparentInput`(`sk`: SecpSecretKey, `utxo`: ZcashOutPoint, `coin`: ZcashTxOut) =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransactionBuilder_add_transparent_input(it, FfiConverterTypeSecpSecretKey.lower(`sk`), FfiConverterTypeZcashOutPoint.lower(`utxo`), FfiConverterTypeZcashTxOut.lower(`coin`),  _status)
}
        }
    
    override fun `addTransparentOutput`(`to`: ZcashTransparentAddress, `value`: ZcashAmount) =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransactionBuilder_add_transparent_output(it, FfiConverterTypeZcashTransparentAddress.lower(`to`), FfiConverterTypeZcashAmount.lower(`value`),  _status)
}
        }
    
    
    @Throws(ZcashException::class)override fun `build`(`prover`: ZcashLocalTxProver, `feeRule`: ZcashFeeRules): ZcashTransactionAndSaplingMetadata =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransactionBuilder_build(it, FfiConverterTypeZcashLocalTxProver.lower(`prover`), FfiConverterTypeZcashFeeRules.lower(`feeRule`),  _status)
}
        }.let {
            FfiConverterTypeZcashTransactionAndSaplingMetadata.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashTransactionBuilder: FfiConverter<ZcashTransactionBuilder, Pointer> {
    override fun lower(value: ZcashTransactionBuilder): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTransactionBuilder {
        return ZcashTransactionBuilder(value)
    }

    override fun read(buf: ByteBuffer): ZcashTransactionBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTransactionBuilder) = 8

    override fun write(value: ZcashTransactionBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashTransparentAddressInterface {
    

    /**
     * Writes a [`TransparentAddress`] as a Base58Check-encoded string. 
     * using the human-readable prefix values defined in the specified 
     * network parameters. 
     */
    fun `encode`(`params`: ZcashConsensusParameters): String
    

    /**
     * Check if it is public key transparent address 
     */
    fun `isPublicKey`(): Boolean
    

    /**
     * Check if it is script transparent address 
     */
    fun `isScript`(): Boolean
    

    fun `script`(): ZcashScript
    

    /**
     * Return raw bytes corresponding to given address 
     */
    fun `toBytes`(): List<UByte>
    
}


/**
 * A transparent address corresponding to either a public key or a `Script`. 
 */
class ZcashTransparentAddress(
    pointer: Pointer
) : FFIObject(pointer), ZcashTransparentAddressInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashTransparentAddress_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentAddress_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `isPublicKey`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentAddress_is_public_key(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `isScript`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentAddress_is_script(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `script`(): ZcashScript =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentAddress_script(it,  _status)
}
        }.let {
            FfiConverterTypeZcashScript.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentAddress_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

    /**
     * Create new transparent address corresponding to public key 
     */
        fun `fromPublicKey`(`data`: List<UByte>): ZcashTransparentAddress =
            ZcashTransparentAddress(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentAddress_from_public_key(FfiConverterSequenceUByte.lower(`data`), _status)
})
        

    /**
     * Create new transparent address corresponding to script 
     */
        fun `fromScript`(`data`: List<UByte>): ZcashTransparentAddress =
            ZcashTransparentAddress(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentAddress_from_script(FfiConverterSequenceUByte.lower(`data`), _status)
})
        

    /**
     * Decodes a [`TransparentAddress`] from a Base58Check-encoded string. 
     */
        fun `decode`(`params`: ZcashConsensusParameters, `input`: String): ZcashTransparentAddress =
            ZcashTransparentAddress(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentAddress_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`input`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashTransparentAddress: FfiConverter<ZcashTransparentAddress, Pointer> {
    override fun lower(value: ZcashTransparentAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTransparentAddress {
        return ZcashTransparentAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashTransparentAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTransparentAddress) = 8

    override fun write(value: ZcashTransparentAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashTransparentBundleInterface {
    

    fun `isCoinbase`(): Boolean
    

    fun `vin`(): List<ZcashTxIn>
    

    fun `vout`(): List<ZcashTxOut>
    
}


class ZcashTransparentBundle(
    pointer: Pointer
) : FFIObject(pointer), ZcashTransparentBundleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashTransparentBundle_object_free(this.pointer, status)
        }
    }

    override fun `isCoinbase`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentBundle_is_coinbase(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `vin`(): List<ZcashTxIn> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentBundle_vin(it,  _status)
}
        }.let {
            FfiConverterSequenceTypeZcashTxIn.lift(it)
        }
    override fun `vout`(): List<ZcashTxOut> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTransparentBundle_vout(it,  _status)
}
        }.let {
            FfiConverterSequenceTypeZcashTxOut.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashTransparentBundle: FfiConverter<ZcashTransparentBundle, Pointer> {
    override fun lower(value: ZcashTransparentBundle): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTransparentBundle {
        return ZcashTransparentBundle(value)
    }

    override fun read(buf: ByteBuffer): ZcashTransparentBundle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTransparentBundle) = 8

    override fun write(value: ZcashTransparentBundle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashTxIdInterface {
    

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
    
}


class ZcashTxId(
    pointer: Pointer
) : FFIObject(pointer), ZcashTxIdInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashTxId_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxId_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>): ZcashTxId =
            ZcashTxId(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxId_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashTxId: FfiConverter<ZcashTxId, Pointer> {
    override fun lower(value: ZcashTxId): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTxId {
        return ZcashTxId(value)
    }

    override fun read(buf: ByteBuffer): ZcashTxId {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTxId) = 8

    override fun write(value: ZcashTxId, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashTxInInterface {
    

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
    
}


class ZcashTxIn(
    pointer: Pointer
) : FFIObject(pointer), ZcashTxInInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashTxIn_object_free(this.pointer, status)
        }
    }

    
    @Throws(ZcashException::class)override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxIn_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashTxIn: FfiConverter<ZcashTxIn, Pointer> {
    override fun lower(value: ZcashTxIn): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTxIn {
        return ZcashTxIn(value)
    }

    override fun read(buf: ByteBuffer): ZcashTxIn {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTxIn) = 8

    override fun write(value: ZcashTxIn, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashTxOutInterface {
    

    fun `value`(): ZcashAmount
    

    fun `scriptPubkey`(): ZcashScript
    

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
    

    fun `recipientAddress`(): ZcashTransparentAddress?
    
}


class ZcashTxOut(
    pointer: Pointer
) : FFIObject(pointer), ZcashTxOutInterface {

    constructor(`value`: ZcashAmount, `scriptPubkey`: ZcashScript) :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxOut_new(FfiConverterTypeZcashAmount.lower(`value`), FfiConverterTypeZcashScript.lower(`scriptPubkey`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashTxOut_object_free(this.pointer, status)
        }
    }

    override fun `value`(): ZcashAmount =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxOut_value(it,  _status)
}
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }
    override fun `scriptPubkey`(): ZcashScript =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxOut_script_pubkey(it,  _status)
}
        }.let {
            FfiConverterTypeZcashScript.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxOut_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `recipientAddress`(): ZcashTransparentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxOut_recipient_address(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashTransparentAddress.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashTxOut: FfiConverter<ZcashTxOut, Pointer> {
    override fun lower(value: ZcashTxOut): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTxOut {
        return ZcashTxOut(value)
    }

    override fun read(buf: ByteBuffer): ZcashTxOut {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTxOut) = 8

    override fun write(value: ZcashTxOut, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashTxVersionInterface {
    

    fun `selection`(): ZcashTxVersionSelection
    

    fun `header`(): UInt
    

    fun `versionGroupId`(): UInt
    

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
    

    fun `hasSprout`(): Boolean
    

    fun `hasOverwinter`(): Boolean
    

    fun `hasSapling`(): Boolean
    

    fun `hasOrchard`(): Boolean
    
}


/**
 * The set of defined transaction format versions. 
 *  
 * This is serialized in the first four or eight bytes of the transaction format, and 
 * represents valid combinations of the `(overwintered, version, version_group_id)` 
 * transaction fields. Note that this is not dependent on epoch, only on transaction encoding. 
 * For example, if a particular epoch defines a new transaction version but also allows the 
 * previous version, then only the new version would be added to this enum. 
 */
class ZcashTxVersion(
    pointer: Pointer
) : FFIObject(pointer), ZcashTxVersionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashTxVersion_object_free(this.pointer, status)
        }
    }

    override fun `selection`(): ZcashTxVersionSelection =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_selection(it,  _status)
}
        }.let {
            FfiConverterTypeZcashTxVersionSelection.lift(it)
        }
    override fun `header`(): UInt =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_header(it,  _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `versionGroupId`(): UInt =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_version_group_id(it,  _status)
}
        }.let {
            FfiConverterUInt.lift(it)
        }
    
    @Throws(ZcashException::class)override fun `toBytes`(): List<UByte> =
        callWithPointer {
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_to_bytes(it,  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `hasSprout`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_has_sprout(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `hasOverwinter`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_has_overwinter(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `hasSapling`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_has_sapling(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `hasOrchard`(): Boolean =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_has_orchard(it,  _status)
}
        }.let {
            FfiConverterBoolean.lift(it)
        }
    

    companion object {
        

        fun `fromBytes`(`data`: List<UByte>): ZcashTxVersion =
            ZcashTxVersion(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
})
        

        fun `suggestedForBranch`(`consensusBranchId`: ZcashBranchId): ZcashTxVersion =
            ZcashTxVersion(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashTxVersion_suggested_for_branch(FfiConverterTypeZcashBranchId.lower(`consensusBranchId`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashTxVersion: FfiConverter<ZcashTxVersion, Pointer> {
    override fun lower(value: ZcashTxVersion): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTxVersion {
        return ZcashTxVersion(value)
    }

    override fun read(buf: ByteBuffer): ZcashTxVersion {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTxVersion) = 8

    override fun write(value: ZcashTxVersion, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashUnifiedAddressInterface {
    

    /**
     * Returns the Orchard receiver within this Unified Address, if any. 
     */
    fun `orchard`(): ZcashOrchardAddress?
    

    /**
     * Returns the Sapling receiver within this Unified Address, if any. 
     */
    fun `sapling`(): ZcashPaymentAddress?
    

    /**
     * Returns the transparent receiver within this Unified Address, if any. 
     */
    fun `transparent`(): ZcashTransparentAddress?
    

    /**
     * Returns the string encoding of this `UnifiedAddress` for the given network. 
     */
    fun `encode`(`params`: ZcashConsensusParameters): String
    
}


/**
 * A Unified Address. 
 */
class ZcashUnifiedAddress(
    pointer: Pointer
) : FFIObject(pointer), ZcashUnifiedAddressInterface {

    /**
     * Constructs a Unified Address from a given set of receivers. 
     *  
     * Returns `None` if the receivers would produce an invalid Unified Address (namely, 
     * if no shielded receiver is provided). 
     */
    constructor(`orchard`: ZcashOrchardAddress?, `sapling`: ZcashPaymentAddress?, `transparent`: ZcashTransparentAddress?) :
        this(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedAddress_new(FfiConverterOptionalTypeZcashOrchardAddress.lower(`orchard`), FfiConverterOptionalTypeZcashPaymentAddress.lower(`sapling`), FfiConverterOptionalTypeZcashTransparentAddress.lower(`transparent`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashUnifiedAddress_object_free(this.pointer, status)
        }
    }

    override fun `orchard`(): ZcashOrchardAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedAddress_orchard(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashOrchardAddress.lift(it)
        }
    override fun `sapling`(): ZcashPaymentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedAddress_sapling(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `transparent`(): ZcashTransparentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedAddress_transparent(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashTransparentAddress.lift(it)
        }
    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedAddress_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    

    companion object {
        

        fun `decode`(`params`: ZcashConsensusParameters, `address`: String): ZcashUnifiedAddress =
            ZcashUnifiedAddress(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedAddress_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`address`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashUnifiedAddress: FfiConverter<ZcashUnifiedAddress, Pointer> {
    override fun lower(value: ZcashUnifiedAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashUnifiedAddress {
        return ZcashUnifiedAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashUnifiedAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashUnifiedAddress) = 8

    override fun write(value: ZcashUnifiedAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashUnifiedFullViewingKeyInterface {
    

    /**
     * Returns the string encoding of this `UnifiedFullViewingKey` for the given network. 
     */
    fun `encode`(`params`: ZcashConsensusParameters): String
    

    /**
     * Returns the transparent component of the unified key at the 
     * BIP44 path `m/44'/<coin_type>'/<account>'`. 
     */
    fun `transparent`(): ZcashAccountPubKey?
    

    /**
     * Returns the Sapling diversifiable full viewing key component of this unified key. 
     */
    fun `sapling`(): ZcashDiversifiableFullViewingKey?
    

    /**
     * Returns the Orchard full viewing key component of this unified key. 
     */
    fun `orchard`(): ZcashOrchardFullViewingKey?
    

    /**
     * Attempts to derive the Unified Address for the given diversifier index. 
     *  
     * Returns `None` if the specified index does not produce a valid diversifier. 
     */
    fun `address`(`j`: ZcashDiversifierIndex): ZcashUnifiedAddress?
    

    /**
     * Searches the diversifier space starting at diversifier index `j` for one which will 
     * produce a valid diversifier, and return the Unified Address constructed using that 
     * diversifier along with the index at which the valid diversifier was found. 
     *  
     * Returns `None` if no valid diversifier exists 
     */
    fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashUnifiedAddressAndDiversifierIndex?
    

    /**
     * Returns the Unified Address corresponding to the smallest valid diversifier index, 
     * along with that index. 
     */
    fun `defaultAddress`(): ZcashUnifiedAddressAndDiversifierIndex
    
}


/**
 * A [ZIP 316](https://zips.z.cash/zip-0316) unified full viewing key. 
 */
class ZcashUnifiedFullViewingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashUnifiedFullViewingKeyInterface {

    /**
     * Construct a new unified full viewing key, if the required components are present. 
     */
    constructor(`transparent`: ZcashAccountPubKey?, `sapling`: ZcashDiversifiableFullViewingKey?, `orchard`: ZcashOrchardFullViewingKey?) :
        this(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedFullViewingKey_new(FfiConverterOptionalTypeZcashAccountPubKey.lower(`transparent`), FfiConverterOptionalTypeZcashDiversifiableFullViewingKey.lower(`sapling`), FfiConverterOptionalTypeZcashOrchardFullViewingKey.lower(`orchard`), _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashUnifiedFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedFullViewingKey_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`),  _status)
}
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `transparent`(): ZcashAccountPubKey? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedFullViewingKey_transparent(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashAccountPubKey.lift(it)
        }
    override fun `sapling`(): ZcashDiversifiableFullViewingKey? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedFullViewingKey_sapling(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashDiversifiableFullViewingKey.lift(it)
        }
    override fun `orchard`(): ZcashOrchardFullViewingKey? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedFullViewingKey_orchard(it,  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashOrchardFullViewingKey.lift(it)
        }
    override fun `address`(`j`: ZcashDiversifierIndex): ZcashUnifiedAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedFullViewingKey_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashUnifiedAddress.lift(it)
        }
    override fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashUnifiedAddressAndDiversifierIndex? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedFullViewingKey_find_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashUnifiedAddressAndDiversifierIndex.lift(it)
        }
    override fun `defaultAddress`(): ZcashUnifiedAddressAndDiversifierIndex =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedFullViewingKey_default_address(it,  _status)
}
        }.let {
            FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.lift(it)
        }
    

    companion object {
        

    /**
     * Parses a `UnifiedFullViewingKey` from its [ZIP 316] string encoding. 
     *  
     * [ZIP 316]: https://zips.z.cash/zip-0316 
     */
        fun `decode`(`params`: ZcashConsensusParameters, `encoded`: String): ZcashUnifiedFullViewingKey =
            ZcashUnifiedFullViewingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedFullViewingKey_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`encoded`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashUnifiedFullViewingKey: FfiConverter<ZcashUnifiedFullViewingKey, Pointer> {
    override fun lower(value: ZcashUnifiedFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashUnifiedFullViewingKey {
        return ZcashUnifiedFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashUnifiedFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashUnifiedFullViewingKey) = 8

    override fun write(value: ZcashUnifiedFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashUnifiedSpendingKeyInterface {
    

    fun `toUnifiedFullViewingKey`(): ZcashUnifiedFullViewingKey
    

    /**
     * Returns the transparent component of the unified key at the 
     * BIP44 path `m/44'/<coin_type>'/<account>'`. 
     */
    fun `transparent`(): ZcashAccountPrivKey
    

    /**
     * Returns the Sapling extended spending key component of this unified spending key. 
     */
    fun `sapling`(): ZcashExtendedSpendingKey
    

    /**
     * Returns the Orchard spending key component of this unified spending key. 
     */
    fun `orchard`(): ZcashOrchardSpendingKey
    

    /**
     * Returns a binary encoding of this key suitable for decoding with [`decode`]. 
     *  
     * The encoded form of a unified spending key is only intended for use 
     * within wallets when required for storage and/or crossing FFI boundaries; 
     * unified spending keys should not be exposed to users, and consequently 
     * no string-based encoding is defined. This encoding does not include any 
     * internal validation metadata (such as checksums) as keys decoded from 
     * this form will necessarily be validated when the attempt is made to 
     * spend a note that they have authority for. 
     */
    fun `toBytes`(`era`: ZcashKeysEra): List<UByte>
    
}


/**
 * A set of viewing keys that are all associated with a single 
 * ZIP-0032 account identifier. 
 */
class ZcashUnifiedSpendingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashUnifiedSpendingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashUnifiedSpendingKey_object_free(this.pointer, status)
        }
    }

    override fun `toUnifiedFullViewingKey`(): ZcashUnifiedFullViewingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedSpendingKey_to_unified_full_viewing_key(it,  _status)
}
        }.let {
            FfiConverterTypeZcashUnifiedFullViewingKey.lift(it)
        }
    override fun `transparent`(): ZcashAccountPrivKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedSpendingKey_transparent(it,  _status)
}
        }.let {
            FfiConverterTypeZcashAccountPrivKey.lift(it)
        }
    override fun `sapling`(): ZcashExtendedSpendingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedSpendingKey_sapling(it,  _status)
}
        }.let {
            FfiConverterTypeZcashExtendedSpendingKey.lift(it)
        }
    override fun `orchard`(): ZcashOrchardSpendingKey =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedSpendingKey_orchard(it,  _status)
}
        }.let {
            FfiConverterTypeZcashOrchardSpendingKey.lift(it)
        }
    override fun `toBytes`(`era`: ZcashKeysEra): List<UByte> =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedSpendingKey_to_bytes(it, FfiConverterTypeZcashKeysEra.lower(`era`),  _status)
}
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    

    companion object {
        

        fun `fromSeed`(`params`: ZcashConsensusParameters, `seed`: List<UByte>, `accountId`: ZcashAccountId): ZcashUnifiedSpendingKey =
            ZcashUnifiedSpendingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedSpendingKey_from_seed(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterSequenceUByte.lower(`seed`), FfiConverterTypeZcashAccountId.lower(`accountId`), _status)
})
        

    /**
     * Decodes a [`UnifiedSpendingKey`] value from its serialized representation. 
     *  
     * See [`to_bytes`] for additional detail about the encoded form. 
     */
        fun `fromBytes`(`era`: ZcashKeysEra, `encoded`: List<UByte>): ZcashUnifiedSpendingKey =
            ZcashUnifiedSpendingKey(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashUnifiedSpendingKey_from_bytes(FfiConverterTypeZcashKeysEra.lower(`era`), FfiConverterSequenceUByte.lower(`encoded`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashUnifiedSpendingKey: FfiConverter<ZcashUnifiedSpendingKey, Pointer> {
    override fun lower(value: ZcashUnifiedSpendingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashUnifiedSpendingKey {
        return ZcashUnifiedSpendingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashUnifiedSpendingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashUnifiedSpendingKey) = 8

    override fun write(value: ZcashUnifiedSpendingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashVerifyingKeyInterface {
    
}


/**
 * The verifying key for the Orchard Action circuit. 
 */
class ZcashVerifyingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashVerifyingKeyInterface {

    /**
     * Builds the verifying key. 
     */
    constructor() :
        this(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashVerifyingKey_new( _status)
})

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashVerifyingKey_object_free(this.pointer, status)
        }
    }

    

    
}

public object FfiConverterTypeZcashVerifyingKey: FfiConverter<ZcashVerifyingKey, Pointer> {
    override fun lower(value: ZcashVerifyingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashVerifyingKey {
        return ZcashVerifyingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashVerifyingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashVerifyingKey) = 8

    override fun write(value: ZcashVerifyingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashViewingKeyInterface {
    

    fun `ivk`(): ZcashSaplingIvk
    

    fun `toPaymentAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress?
    
}


class ZcashViewingKey(
    pointer: Pointer
) : FFIObject(pointer), ZcashViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `ivk`(): ZcashSaplingIvk =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashViewingKey_ivk(it,  _status)
}
        }.let {
            FfiConverterTypeZcashSaplingIvk.lift(it)
        }
    override fun `toPaymentAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress? =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashViewingKey_to_payment_address(it, FfiConverterTypeZcashDiversifier.lower(`diversifier`),  _status)
}
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    

    
}

public object FfiConverterTypeZcashViewingKey: FfiConverter<ZcashViewingKey, Pointer> {
    override fun lower(value: ZcashViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashViewingKey {
        return ZcashViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashViewingKey) = 8

    override fun write(value: ZcashViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}




public interface ZcashZip317FeeRuleInterface {
    

    fun `marginalFee`(): ZcashAmount
    
}


class ZcashZip317FeeRule(
    pointer: Pointer
) : FFIObject(pointer), ZcashZip317FeeRuleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    override protected fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_6e86_ZcashZip317FeeRule_object_free(this.pointer, status)
        }
    }

    override fun `marginalFee`(): ZcashAmount =
        callWithPointer {
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashZip317FeeRule_marginal_fee(it,  _status)
}
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }
    

    companion object {
        

        fun `standard`(): ZcashZip317FeeRule =
            ZcashZip317FeeRule(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashZip317FeeRule_standard( _status)
})
        

        fun `nonStandard`(`marginalFee`: ZcashAmount, `graceActions`: ULong, `p2pkhStandardInputSize`: ULong, `p2pkhStandardOutputSize`: ULong): ZcashZip317FeeRule =
            ZcashZip317FeeRule(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_ZcashZip317FeeRule_non_standard(FfiConverterTypeZcashAmount.lower(`marginalFee`), FfiConverterULong.lower(`graceActions`), FfiConverterULong.lower(`p2pkhStandardInputSize`), FfiConverterULong.lower(`p2pkhStandardOutputSize`), _status)
})
        
    }
    
}

public object FfiConverterTypeZcashZip317FeeRule: FfiConverter<ZcashZip317FeeRule, Pointer> {
    override fun lower(value: ZcashZip317FeeRule): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashZip317FeeRule {
        return ZcashZip317FeeRule(value)
    }

    override fun read(buf: ByteBuffer): ZcashZip317FeeRule {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashZip317FeeRule) = 8

    override fun write(value: ZcashZip317FeeRule, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}





/**
 * A type-safe wrapper for account identifiers. 
 */
data class ZcashAccountId (
    var `id`: UInt
) {
    
}

public object FfiConverterTypeZcashAccountId: FfiConverterRustBuffer<ZcashAccountId> {
    override fun read(buf: ByteBuffer): ZcashAccountId {
        return ZcashAccountId(
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: ZcashAccountId) = (
            FfiConverterUInt.allocationSize(value.`id`)
    )

    override fun write(value: ZcashAccountId, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`id`, buf)
    }
}





data class ZcashAuthPath (
    var `node`: ZcashSaplingNode, 
    var `bool`: Boolean
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`node`, 
        this.`bool`)
    }
    
}

public object FfiConverterTypeZcashAuthPath: FfiConverterRustBuffer<ZcashAuthPath> {
    override fun read(buf: ByteBuffer): ZcashAuthPath {
        return ZcashAuthPath(
            FfiConverterTypeZcashSaplingNode.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: ZcashAuthPath) = (
            FfiConverterTypeZcashSaplingNode.allocationSize(value.`node`) +
            FfiConverterBoolean.allocationSize(value.`bool`)
    )

    override fun write(value: ZcashAuthPath, buf: ByteBuffer) {
            FfiConverterTypeZcashSaplingNode.write(value.`node`, buf)
            FfiConverterBoolean.write(value.`bool`, buf)
    }
}





data class ZcashDiversifierIndexAndPaymentAddress (
    var `diversifierIndex`: ZcashDiversifierIndex, 
    var `address`: ZcashPaymentAddress
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`diversifierIndex`, 
        this.`address`)
    }
    
}

public object FfiConverterTypeZcashDiversifierIndexAndPaymentAddress: FfiConverterRustBuffer<ZcashDiversifierIndexAndPaymentAddress> {
    override fun read(buf: ByteBuffer): ZcashDiversifierIndexAndPaymentAddress {
        return ZcashDiversifierIndexAndPaymentAddress(
            FfiConverterTypeZcashDiversifierIndex.read(buf),
            FfiConverterTypeZcashPaymentAddress.read(buf),
        )
    }

    override fun allocationSize(value: ZcashDiversifierIndexAndPaymentAddress) = (
            FfiConverterTypeZcashDiversifierIndex.allocationSize(value.`diversifierIndex`) +
            FfiConverterTypeZcashPaymentAddress.allocationSize(value.`address`)
    )

    override fun write(value: ZcashDiversifierIndexAndPaymentAddress, buf: ByteBuffer) {
            FfiConverterTypeZcashDiversifierIndex.write(value.`diversifierIndex`, buf)
            FfiConverterTypeZcashPaymentAddress.write(value.`address`, buf)
    }
}





data class ZcashDiversifierIndexAndScope (
    var `diversifierIndex`: ZcashDiversifierIndex, 
    var `scope`: ZcashScope
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`diversifierIndex`, 
        this.`scope`)
    }
    
}

public object FfiConverterTypeZcashDiversifierIndexAndScope: FfiConverterRustBuffer<ZcashDiversifierIndexAndScope> {
    override fun read(buf: ByteBuffer): ZcashDiversifierIndexAndScope {
        return ZcashDiversifierIndexAndScope(
            FfiConverterTypeZcashDiversifierIndex.read(buf),
            FfiConverterTypeZcashScope.read(buf),
        )
    }

    override fun allocationSize(value: ZcashDiversifierIndexAndScope) = (
            FfiConverterTypeZcashDiversifierIndex.allocationSize(value.`diversifierIndex`) +
            FfiConverterTypeZcashScope.allocationSize(value.`scope`)
    )

    override fun write(value: ZcashDiversifierIndexAndScope, buf: ByteBuffer) {
            FfiConverterTypeZcashDiversifierIndex.write(value.`diversifierIndex`, buf)
            FfiConverterTypeZcashScope.write(value.`scope`, buf)
    }
}





data class ZcashInternalOvkExternalOvk (
    var `internalOvk`: ZcashInternalOvk, 
    var `externalOvk`: ZcashExternalOvk
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`internalOvk`, 
        this.`externalOvk`)
    }
    
}

public object FfiConverterTypeZcashInternalOvkExternalOvk: FfiConverterRustBuffer<ZcashInternalOvkExternalOvk> {
    override fun read(buf: ByteBuffer): ZcashInternalOvkExternalOvk {
        return ZcashInternalOvkExternalOvk(
            FfiConverterTypeZcashInternalOvk.read(buf),
            FfiConverterTypeZcashExternalOvk.read(buf),
        )
    }

    override fun allocationSize(value: ZcashInternalOvkExternalOvk) = (
            FfiConverterTypeZcashInternalOvk.allocationSize(value.`internalOvk`) +
            FfiConverterTypeZcashExternalOvk.allocationSize(value.`externalOvk`)
    )

    override fun write(value: ZcashInternalOvkExternalOvk, buf: ByteBuffer) {
            FfiConverterTypeZcashInternalOvk.write(value.`internalOvk`, buf)
            FfiConverterTypeZcashExternalOvk.write(value.`externalOvk`, buf)
    }
}





data class ZcashOrchardDecryptOutput (
    var `note`: ZcashOrchardNote, 
    var `address`: ZcashOrchardAddress, 
    var `data`: List<UByte>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`note`, 
        this.`address`, 
        this.`data`)
    }
    
}

public object FfiConverterTypeZcashOrchardDecryptOutput: FfiConverterRustBuffer<ZcashOrchardDecryptOutput> {
    override fun read(buf: ByteBuffer): ZcashOrchardDecryptOutput {
        return ZcashOrchardDecryptOutput(
            FfiConverterTypeZcashOrchardNote.read(buf),
            FfiConverterTypeZcashOrchardAddress.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: ZcashOrchardDecryptOutput) = (
            FfiConverterTypeZcashOrchardNote.allocationSize(value.`note`) +
            FfiConverterTypeZcashOrchardAddress.allocationSize(value.`address`) +
            FfiConverterSequenceUByte.allocationSize(value.`data`)
    )

    override fun write(value: ZcashOrchardDecryptOutput, buf: ByteBuffer) {
            FfiConverterTypeZcashOrchardNote.write(value.`note`, buf)
            FfiConverterTypeZcashOrchardAddress.write(value.`address`, buf)
            FfiConverterSequenceUByte.write(value.`data`, buf)
    }
}





data class ZcashOrchardDecryptOutputForIncomingKeys (
    var `idx`: ULong, 
    var `key`: ZcashOrchardIncomingViewingKey, 
    var `note`: ZcashOrchardNote, 
    var `address`: ZcashOrchardAddress, 
    var `data`: List<UByte>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`idx`, 
        this.`key`, 
        this.`note`, 
        this.`address`, 
        this.`data`)
    }
    
}

public object FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys: FfiConverterRustBuffer<ZcashOrchardDecryptOutputForIncomingKeys> {
    override fun read(buf: ByteBuffer): ZcashOrchardDecryptOutputForIncomingKeys {
        return ZcashOrchardDecryptOutputForIncomingKeys(
            FfiConverterULong.read(buf),
            FfiConverterTypeZcashOrchardIncomingViewingKey.read(buf),
            FfiConverterTypeZcashOrchardNote.read(buf),
            FfiConverterTypeZcashOrchardAddress.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: ZcashOrchardDecryptOutputForIncomingKeys) = (
            FfiConverterULong.allocationSize(value.`idx`) +
            FfiConverterTypeZcashOrchardIncomingViewingKey.allocationSize(value.`key`) +
            FfiConverterTypeZcashOrchardNote.allocationSize(value.`note`) +
            FfiConverterTypeZcashOrchardAddress.allocationSize(value.`address`) +
            FfiConverterSequenceUByte.allocationSize(value.`data`)
    )

    override fun write(value: ZcashOrchardDecryptOutputForIncomingKeys, buf: ByteBuffer) {
            FfiConverterULong.write(value.`idx`, buf)
            FfiConverterTypeZcashOrchardIncomingViewingKey.write(value.`key`, buf)
            FfiConverterTypeZcashOrchardNote.write(value.`note`, buf)
            FfiConverterTypeZcashOrchardAddress.write(value.`address`, buf)
            FfiConverterSequenceUByte.write(value.`data`, buf)
    }
}





data class ZcashOrchardDecryptOutputForOutgoingKeys (
    var `idx`: ULong, 
    var `key`: ZcashOrchardOutgoingViewingKey, 
    var `note`: ZcashOrchardNote, 
    var `address`: ZcashOrchardAddress, 
    var `data`: List<UByte>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`idx`, 
        this.`key`, 
        this.`note`, 
        this.`address`, 
        this.`data`)
    }
    
}

public object FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys: FfiConverterRustBuffer<ZcashOrchardDecryptOutputForOutgoingKeys> {
    override fun read(buf: ByteBuffer): ZcashOrchardDecryptOutputForOutgoingKeys {
        return ZcashOrchardDecryptOutputForOutgoingKeys(
            FfiConverterULong.read(buf),
            FfiConverterTypeZcashOrchardOutgoingViewingKey.read(buf),
            FfiConverterTypeZcashOrchardNote.read(buf),
            FfiConverterTypeZcashOrchardAddress.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: ZcashOrchardDecryptOutputForOutgoingKeys) = (
            FfiConverterULong.allocationSize(value.`idx`) +
            FfiConverterTypeZcashOrchardOutgoingViewingKey.allocationSize(value.`key`) +
            FfiConverterTypeZcashOrchardNote.allocationSize(value.`note`) +
            FfiConverterTypeZcashOrchardAddress.allocationSize(value.`address`) +
            FfiConverterSequenceUByte.allocationSize(value.`data`)
    )

    override fun write(value: ZcashOrchardDecryptOutputForOutgoingKeys, buf: ByteBuffer) {
            FfiConverterULong.write(value.`idx`, buf)
            FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value.`key`, buf)
            FfiConverterTypeZcashOrchardNote.write(value.`note`, buf)
            FfiConverterTypeZcashOrchardAddress.write(value.`address`, buf)
            FfiConverterSequenceUByte.write(value.`data`, buf)
    }
}





/**
 * An encrypted note. 
 *
 * @property epk_bytes The serialization of the ephemeral public key (32 bytes).
 * @property enc_ciphertext The encrypted note ciphertext (580 bytes).
 * @property out_ciphertext An encrypted value that allows the holder of the outgoing cipher key for the note to recover the note plaintext. (80 bytes)
 */
data class ZcashOrchardTransmittedNoteCiphertext (
    var `epkBytes`: List<UByte>, 
    var `encCiphertext`: List<UByte>, 
    var `outCiphertext`: List<UByte>
) {
    
}

public object FfiConverterTypeZcashOrchardTransmittedNoteCiphertext: FfiConverterRustBuffer<ZcashOrchardTransmittedNoteCiphertext> {
    override fun read(buf: ByteBuffer): ZcashOrchardTransmittedNoteCiphertext {
        return ZcashOrchardTransmittedNoteCiphertext(
            FfiConverterSequenceUByte.read(buf),
            FfiConverterSequenceUByte.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: ZcashOrchardTransmittedNoteCiphertext) = (
            FfiConverterSequenceUByte.allocationSize(value.`epkBytes`) +
            FfiConverterSequenceUByte.allocationSize(value.`encCiphertext`) +
            FfiConverterSequenceUByte.allocationSize(value.`outCiphertext`)
    )

    override fun write(value: ZcashOrchardTransmittedNoteCiphertext, buf: ByteBuffer) {
            FfiConverterSequenceUByte.write(value.`epkBytes`, buf)
            FfiConverterSequenceUByte.write(value.`encCiphertext`, buf)
            FfiConverterSequenceUByte.write(value.`outCiphertext`, buf)
    }
}





data class ZcashPayment (
    var `recipentAddress`: ZcashRecipientAddress, 
    var `amount`: Long, 
    var `memo`: ZcashMemoBytes?, 
    var `label`: String?, 
    var `message`: String?, 
    var `otherParams`: List<ZcashPaymentParam>
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`recipentAddress`, 
        this.`amount`, 
        this.`memo`, 
        this.`label`, 
        this.`message`, 
        this.`otherParams`)
    }
    
}

public object FfiConverterTypeZcashPayment: FfiConverterRustBuffer<ZcashPayment> {
    override fun read(buf: ByteBuffer): ZcashPayment {
        return ZcashPayment(
            FfiConverterTypeZcashRecipientAddress.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalTypeZcashMemoBytes.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterSequenceTypeZcashPaymentParam.read(buf),
        )
    }

    override fun allocationSize(value: ZcashPayment) = (
            FfiConverterTypeZcashRecipientAddress.allocationSize(value.`recipentAddress`) +
            FfiConverterLong.allocationSize(value.`amount`) +
            FfiConverterOptionalTypeZcashMemoBytes.allocationSize(value.`memo`) +
            FfiConverterOptionalString.allocationSize(value.`label`) +
            FfiConverterOptionalString.allocationSize(value.`message`) +
            FfiConverterSequenceTypeZcashPaymentParam.allocationSize(value.`otherParams`)
    )

    override fun write(value: ZcashPayment, buf: ByteBuffer) {
            FfiConverterTypeZcashRecipientAddress.write(value.`recipentAddress`, buf)
            FfiConverterLong.write(value.`amount`, buf)
            FfiConverterOptionalTypeZcashMemoBytes.write(value.`memo`, buf)
            FfiConverterOptionalString.write(value.`label`, buf)
            FfiConverterOptionalString.write(value.`message`, buf)
            FfiConverterSequenceTypeZcashPaymentParam.write(value.`otherParams`, buf)
    }
}





data class ZcashPaymentParam (
    var `key`: String, 
    var `value`: String
) {
    
}

public object FfiConverterTypeZcashPaymentParam: FfiConverterRustBuffer<ZcashPaymentParam> {
    override fun read(buf: ByteBuffer): ZcashPaymentParam {
        return ZcashPaymentParam(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ZcashPaymentParam) = (
            FfiConverterString.allocationSize(value.`key`) +
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: ZcashPaymentParam, buf: ByteBuffer) {
            FfiConverterString.write(value.`key`, buf)
            FfiConverterString.write(value.`value`, buf)
    }
}





data class ZcashTransactionAndSaplingMetadata (
    var `transaction`: ZcashTransaction, 
    var `saplingMetadata`: ZcashSaplingMetadata
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`transaction`, 
        this.`saplingMetadata`)
    }
    
}

public object FfiConverterTypeZcashTransactionAndSaplingMetadata: FfiConverterRustBuffer<ZcashTransactionAndSaplingMetadata> {
    override fun read(buf: ByteBuffer): ZcashTransactionAndSaplingMetadata {
        return ZcashTransactionAndSaplingMetadata(
            FfiConverterTypeZcashTransaction.read(buf),
            FfiConverterTypeZcashSaplingMetadata.read(buf),
        )
    }

    override fun allocationSize(value: ZcashTransactionAndSaplingMetadata) = (
            FfiConverterTypeZcashTransaction.allocationSize(value.`transaction`) +
            FfiConverterTypeZcashSaplingMetadata.allocationSize(value.`saplingMetadata`)
    )

    override fun write(value: ZcashTransactionAndSaplingMetadata, buf: ByteBuffer) {
            FfiConverterTypeZcashTransaction.write(value.`transaction`, buf)
            FfiConverterTypeZcashSaplingMetadata.write(value.`saplingMetadata`, buf)
    }
}





data class ZcashTransparentAddressAndIndex (
    var `transparentAddress`: ZcashTransparentAddress, 
    var `index`: UInt
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`transparentAddress`, 
        this.`index`)
    }
    
}

public object FfiConverterTypeZcashTransparentAddressAndIndex: FfiConverterRustBuffer<ZcashTransparentAddressAndIndex> {
    override fun read(buf: ByteBuffer): ZcashTransparentAddressAndIndex {
        return ZcashTransparentAddressAndIndex(
            FfiConverterTypeZcashTransparentAddress.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: ZcashTransparentAddressAndIndex) = (
            FfiConverterTypeZcashTransparentAddress.allocationSize(value.`transparentAddress`) +
            FfiConverterUInt.allocationSize(value.`index`)
    )

    override fun write(value: ZcashTransparentAddressAndIndex, buf: ByteBuffer) {
            FfiConverterTypeZcashTransparentAddress.write(value.`transparentAddress`, buf)
            FfiConverterUInt.write(value.`index`, buf)
    }
}





data class ZcashUnifiedAddressAndDiversifierIndex (
    var `address`: ZcashUnifiedAddress, 
    var `diversifierIndex`: ZcashDiversifierIndex
) : Disposable {
    
    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        
    Disposable.destroy(
        this.`address`, 
        this.`diversifierIndex`)
    }
    
}

public object FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex: FfiConverterRustBuffer<ZcashUnifiedAddressAndDiversifierIndex> {
    override fun read(buf: ByteBuffer): ZcashUnifiedAddressAndDiversifierIndex {
        return ZcashUnifiedAddressAndDiversifierIndex(
            FfiConverterTypeZcashUnifiedAddress.read(buf),
            FfiConverterTypeZcashDiversifierIndex.read(buf),
        )
    }

    override fun allocationSize(value: ZcashUnifiedAddressAndDiversifierIndex) = (
            FfiConverterTypeZcashUnifiedAddress.allocationSize(value.`address`) +
            FfiConverterTypeZcashDiversifierIndex.allocationSize(value.`diversifierIndex`)
    )

    override fun write(value: ZcashUnifiedAddressAndDiversifierIndex, buf: ByteBuffer) {
            FfiConverterTypeZcashUnifiedAddress.write(value.`address`, buf)
            FfiConverterTypeZcashDiversifierIndex.write(value.`diversifierIndex`, buf)
    }
}





enum class ZcashBranchId {
    
    SPROUT,
    OVERWINTER,
    SAPLING,
    BLOSSOM,
    HEARTWOOD,
    CANOPY,
    NU5;
}

public object FfiConverterTypeZcashBranchId: FfiConverterRustBuffer<ZcashBranchId> {
    override fun read(buf: ByteBuffer) = try {
        ZcashBranchId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashBranchId) = 4

    override fun write(value: ZcashBranchId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * A child index for a derived key 
 */
sealed class ZcashChildIndex {
    data class NonHardened(
        val `v`: UInt
        ) : ZcashChildIndex()
    data class Hardened(
        val `v`: UInt
        ) : ZcashChildIndex()
    

    
}

public object FfiConverterTypeZcashChildIndex : FfiConverterRustBuffer<ZcashChildIndex>{
    override fun read(buf: ByteBuffer): ZcashChildIndex {
        return when(buf.getInt()) {
            1 -> ZcashChildIndex.NonHardened(
                FfiConverterUInt.read(buf),
                )
            2 -> ZcashChildIndex.Hardened(
                FfiConverterUInt.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ZcashChildIndex) = when(value) {
        is ZcashChildIndex.NonHardened -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUInt.allocationSize(value.`v`)
            )
        }
        is ZcashChildIndex.Hardened -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUInt.allocationSize(value.`v`)
            )
        }
    }

    override fun write(value: ZcashChildIndex, buf: ByteBuffer) {
        when(value) {
            is ZcashChildIndex.NonHardened -> {
                buf.putInt(1)
                FfiConverterUInt.write(value.`v`, buf)
                Unit
            }
            is ZcashChildIndex.Hardened -> {
                buf.putInt(2)
                FfiConverterUInt.write(value.`v`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







/**
 * Zcash consensus parameters. 
 */
enum class ZcashConsensusParameters {
    
    /**
     * Marker struct for the production network. 
     */
    MAIN_NETWORK,
    /**
     * Marker struct for the test network. 
     */
    TEST_NETWORK;
}

public object FfiConverterTypeZcashConsensusParameters: FfiConverterRustBuffer<ZcashConsensusParameters> {
    override fun read(buf: ByteBuffer) = try {
        ZcashConsensusParameters.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashConsensusParameters) = 4

    override fun write(value: ZcashConsensusParameters, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * A selector for the desired fee rules for applying to a transaction. 
 */
sealed class ZcashFeeRules {
    object FixedStandard : ZcashFeeRules()
    
    data class FixedNonStandard(
        val `amount`: ULong
        ) : ZcashFeeRules()
    object Zip317Standard : ZcashFeeRules()
    
    data class Zip317NonStandard(
        val `marginalFee`: ULong, 
        val `graceActions`: ULong, 
        val `p2pkhStandardInputSize`: ULong, 
        val `p2pkhStandardOutputSize`: ULong
        ) : ZcashFeeRules()
    

    
}

public object FfiConverterTypeZcashFeeRules : FfiConverterRustBuffer<ZcashFeeRules>{
    override fun read(buf: ByteBuffer): ZcashFeeRules {
        return when(buf.getInt()) {
            1 -> ZcashFeeRules.FixedStandard
            2 -> ZcashFeeRules.FixedNonStandard(
                FfiConverterULong.read(buf),
                )
            3 -> ZcashFeeRules.Zip317Standard
            4 -> ZcashFeeRules.Zip317NonStandard(
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ZcashFeeRules) = when(value) {
        is ZcashFeeRules.FixedStandard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is ZcashFeeRules.FixedNonStandard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`amount`)
            )
        }
        is ZcashFeeRules.Zip317Standard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is ZcashFeeRules.Zip317NonStandard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`marginalFee`)
                + FfiConverterULong.allocationSize(value.`graceActions`)
                + FfiConverterULong.allocationSize(value.`p2pkhStandardInputSize`)
                + FfiConverterULong.allocationSize(value.`p2pkhStandardOutputSize`)
            )
        }
    }

    override fun write(value: ZcashFeeRules, buf: ByteBuffer) {
        when(value) {
            is ZcashFeeRules.FixedStandard -> {
                buf.putInt(1)
                Unit
            }
            is ZcashFeeRules.FixedNonStandard -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`amount`, buf)
                Unit
            }
            is ZcashFeeRules.Zip317Standard -> {
                buf.putInt(3)
                Unit
            }
            is ZcashFeeRules.Zip317NonStandard -> {
                buf.putInt(4)
                FfiConverterULong.write(value.`marginalFee`, buf)
                FfiConverterULong.write(value.`graceActions`, buf)
                FfiConverterULong.write(value.`p2pkhStandardInputSize`, buf)
                FfiConverterULong.write(value.`p2pkhStandardOutputSize`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







/**
 * Indicate bits of random seed used to generate private key, 256 is recommended. 
 */
enum class ZcashKeySeed {
    
    S128,
    S256,
    S512;
}

public object FfiConverterTypeZcashKeySeed: FfiConverterRustBuffer<ZcashKeySeed> {
    override fun read(buf: ByteBuffer) = try {
        ZcashKeySeed.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashKeySeed) = 4

    override fun write(value: ZcashKeySeed, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * A version identifier for the encoding of unified spending keys. 
 *  
 * Each era corresponds to a range of block heights. During an era, the unified spending key 
 * parsed from an encoded form tagged with that era's identifier is expected to provide 
 * sufficient spending authority to spend any non-Sprout shielded note created in a transaction 
 * within the era's block range. 
 */
enum class ZcashKeysEra {
    
    /**
     * The Orchard era begins at Orchard activation, and will end if a new pool that requires a 
     * change to unified spending keys is introduced. 
     */
    ORCHARD;
}

public object FfiConverterTypeZcashKeysEra: FfiConverterRustBuffer<ZcashKeysEra> {
    override fun read(buf: ByteBuffer) = try {
        ZcashKeysEra.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashKeysEra) = 4

    override fun write(value: ZcashKeysEra, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * The scope of a viewing key or address. 
 */
enum class ZcashOrchardScope {
    
    /**
     * A scope used for wallet-external operations, namely deriving addresses to give to 
     * other users in order to receive funds. 
     */
    EXTERNAL,
    /**
     * A scope used for wallet-internal operations, such as creating change notes, 
     * auto-shielding, and note management. 
     */
    INTERNAL;
}

public object FfiConverterTypeZcashOrchardScope: FfiConverterRustBuffer<ZcashOrchardScope> {
    override fun read(buf: ByteBuffer) = try {
        ZcashOrchardScope.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashOrchardScope) = 4

    override fun write(value: ZcashOrchardScope, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







/**
 * Enum for note randomness before and after [ZIP 212](https://zips.z.cash/zip-0212). 
 *  
 * Before ZIP 212, the note commitment trapdoor `rcm` must be a scalar value. 
 * After ZIP 212, the note randomness `rseed` is a 32-byte sequence, used to derive 
 * both the note commitment trapdoor `rcm` and the ephemeral private key `esk`. 
 */
sealed class ZcashRseed {
    data class BeforeZip212(
        val `frData`: List<UByte>
        ) : ZcashRseed()
    data class AfterZip212(
        val `data`: List<UByte>
        ) : ZcashRseed()
    

    
}

public object FfiConverterTypeZcashRseed : FfiConverterRustBuffer<ZcashRseed>{
    override fun read(buf: ByteBuffer): ZcashRseed {
        return when(buf.getInt()) {
            1 -> ZcashRseed.BeforeZip212(
                FfiConverterSequenceUByte.read(buf),
                )
            2 -> ZcashRseed.AfterZip212(
                FfiConverterSequenceUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ZcashRseed) = when(value) {
        is ZcashRseed.BeforeZip212 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`frData`)
            )
        }
        is ZcashRseed.AfterZip212 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterSequenceUByte.allocationSize(value.`data`)
            )
        }
    }

    override fun write(value: ZcashRseed, buf: ByteBuffer) {
        when(value) {
            is ZcashRseed.BeforeZip212 -> {
                buf.putInt(1)
                FfiConverterSequenceUByte.write(value.`frData`, buf)
                Unit
            }
            is ZcashRseed.AfterZip212 -> {
                buf.putInt(2)
                FfiConverterSequenceUByte.write(value.`data`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







/**
 * The scope of a viewing key or address. 
 *  
 * A "scope" narrows the visibility or usage to a level below "full". 
 *  
 * Consistent usage of `Scope` enables the user to provide consistent views over a wallet 
 * to other people. For example, a user can give an external [SaplingIvk] to a merchant 
 * terminal, enabling it to only detect "real" transactions from customers and not 
 * internal transactions from the wallet. 
 *  
 * [SaplingIvk]: ZcashSaplingIvk 
 */
enum class ZcashScope {
    
    /**
     * A scope used for wallet-external operations, namely deriving addresses to give to 
     * other users in order to receive funds. 
     */
    EXTERNAL,
    /**
     * A scope used for wallet-internal operations, such as creating change notes, 
     * auto-shielding, and note management. 
     */
    INTERNAL;
}

public object FfiConverterTypeZcashScope: FfiConverterRustBuffer<ZcashScope> {
    override fun read(buf: ByteBuffer) = try {
        ZcashScope.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashScope) = 4

    override fun write(value: ZcashScope, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class ZcashTxVersionSelection {
    data class Sprout(
        val `v`: UInt
        ) : ZcashTxVersionSelection()
    object Overwinter : ZcashTxVersionSelection()
    
    object Sapling : ZcashTxVersionSelection()
    
    object Zip225 : ZcashTxVersionSelection()
    
    

    
}

public object FfiConverterTypeZcashTxVersionSelection : FfiConverterRustBuffer<ZcashTxVersionSelection>{
    override fun read(buf: ByteBuffer): ZcashTxVersionSelection {
        return when(buf.getInt()) {
            1 -> ZcashTxVersionSelection.Sprout(
                FfiConverterUInt.read(buf),
                )
            2 -> ZcashTxVersionSelection.Overwinter
            3 -> ZcashTxVersionSelection.Sapling
            4 -> ZcashTxVersionSelection.Zip225
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ZcashTxVersionSelection) = when(value) {
        is ZcashTxVersionSelection.Sprout -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterUInt.allocationSize(value.`v`)
            )
        }
        is ZcashTxVersionSelection.Overwinter -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is ZcashTxVersionSelection.Sapling -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is ZcashTxVersionSelection.Zip225 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
    }

    override fun write(value: ZcashTxVersionSelection, buf: ByteBuffer) {
        when(value) {
            is ZcashTxVersionSelection.Sprout -> {
                buf.putInt(1)
                FfiConverterUInt.write(value.`v`, buf)
                Unit
            }
            is ZcashTxVersionSelection.Overwinter -> {
                buf.putInt(2)
                Unit
            }
            is ZcashTxVersionSelection.Sapling -> {
                buf.putInt(3)
                Unit
            }
            is ZcashTxVersionSelection.Zip225 -> {
                buf.putInt(4)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class ZcashException(message: String): Exception(message) {
        // Each variant is a nested class
        // Flat enums carries a string error message, so no special implementation is necessary.
        class HdWalletException(message: String) : ZcashException(message)
        class DecodingException(message: String) : ZcashException(message)
        class DerivationException(message: String) : ZcashException(message)
        class InvalidAsk(message: String) : ZcashException(message)
        class InvalidNsk(message: String) : ZcashException(message)
        class Message(message: String) : ZcashException(message)
        class ArrayLengthMismatch(message: String) : ZcashException(message)
        class ValueOutOfRange(message: String) : ZcashException(message)
        class Secp256k1Exception(message: String) : ZcashException(message)
        class Bech32DecodeException(message: String) : ZcashException(message)
        class Bs58Exception(message: String) : ZcashException(message)
        class BuilderException(message: String) : ZcashException(message)
        class TransparentBuilderException(message: String) : ZcashException(message)
        class SaplingBuilderException(message: String) : ZcashException(message)
        class OrchardBuilderException(message: String) : ZcashException(message)
        class InsufficientFundsException(message: String) : ZcashException(message)
        class ChangeRequiredException(message: String) : ZcashException(message)
        class BalanceException(message: String) : ZcashException(message)
        class IoException(message: String) : ZcashException(message)
        class Unknown(message: String) : ZcashException(message)
        

    companion object ErrorHandler : CallStatusErrorHandler<ZcashException> {
        override fun lift(error_buf: RustBuffer.ByValue): ZcashException = FfiConverterTypeZcashError.lift(error_buf)
    }
}

public object FfiConverterTypeZcashError : FfiConverterRustBuffer<ZcashException> {
    override fun read(buf: ByteBuffer): ZcashException {
        
            return when(buf.getInt()) {
            1 -> ZcashException.HdWalletException(FfiConverterString.read(buf))
            2 -> ZcashException.DecodingException(FfiConverterString.read(buf))
            3 -> ZcashException.DerivationException(FfiConverterString.read(buf))
            4 -> ZcashException.InvalidAsk(FfiConverterString.read(buf))
            5 -> ZcashException.InvalidNsk(FfiConverterString.read(buf))
            6 -> ZcashException.Message(FfiConverterString.read(buf))
            7 -> ZcashException.ArrayLengthMismatch(FfiConverterString.read(buf))
            8 -> ZcashException.ValueOutOfRange(FfiConverterString.read(buf))
            9 -> ZcashException.Secp256k1Exception(FfiConverterString.read(buf))
            10 -> ZcashException.Bech32DecodeException(FfiConverterString.read(buf))
            11 -> ZcashException.Bs58Exception(FfiConverterString.read(buf))
            12 -> ZcashException.BuilderException(FfiConverterString.read(buf))
            13 -> ZcashException.TransparentBuilderException(FfiConverterString.read(buf))
            14 -> ZcashException.SaplingBuilderException(FfiConverterString.read(buf))
            15 -> ZcashException.OrchardBuilderException(FfiConverterString.read(buf))
            16 -> ZcashException.InsufficientFundsException(FfiConverterString.read(buf))
            17 -> ZcashException.ChangeRequiredException(FfiConverterString.read(buf))
            18 -> ZcashException.BalanceException(FfiConverterString.read(buf))
            19 -> ZcashException.IoException(FfiConverterString.read(buf))
            20 -> ZcashException.Unknown(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: ZcashException): Int {
        return 4
    }

    override fun write(value: ZcashException, buf: ByteBuffer) {
        when(value) {
            is ZcashException.HdWalletException -> {
                buf.putInt(1)
                Unit
            }
            is ZcashException.DecodingException -> {
                buf.putInt(2)
                Unit
            }
            is ZcashException.DerivationException -> {
                buf.putInt(3)
                Unit
            }
            is ZcashException.InvalidAsk -> {
                buf.putInt(4)
                Unit
            }
            is ZcashException.InvalidNsk -> {
                buf.putInt(5)
                Unit
            }
            is ZcashException.Message -> {
                buf.putInt(6)
                Unit
            }
            is ZcashException.ArrayLengthMismatch -> {
                buf.putInt(7)
                Unit
            }
            is ZcashException.ValueOutOfRange -> {
                buf.putInt(8)
                Unit
            }
            is ZcashException.Secp256k1Exception -> {
                buf.putInt(9)
                Unit
            }
            is ZcashException.Bech32DecodeException -> {
                buf.putInt(10)
                Unit
            }
            is ZcashException.Bs58Exception -> {
                buf.putInt(11)
                Unit
            }
            is ZcashException.BuilderException -> {
                buf.putInt(12)
                Unit
            }
            is ZcashException.TransparentBuilderException -> {
                buf.putInt(13)
                Unit
            }
            is ZcashException.SaplingBuilderException -> {
                buf.putInt(14)
                Unit
            }
            is ZcashException.OrchardBuilderException -> {
                buf.putInt(15)
                Unit
            }
            is ZcashException.InsufficientFundsException -> {
                buf.putInt(16)
                Unit
            }
            is ZcashException.ChangeRequiredException -> {
                buf.putInt(17)
                Unit
            }
            is ZcashException.BalanceException -> {
                buf.putInt(18)
                Unit
            }
            is ZcashException.IoException -> {
                buf.putInt(19)
                Unit
            }
            is ZcashException.Unknown -> {
                buf.putInt(20)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}




public object FfiConverterOptionalULong: FfiConverterRustBuffer<ULong?> {
    override fun read(buf: ByteBuffer): ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: ULong?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




public object FfiConverterOptionalString: FfiConverterRustBuffer<String?> {
    override fun read(buf: ByteBuffer): String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: String?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashAccountPubKey: FfiConverterRustBuffer<ZcashAccountPubKey?> {
    override fun read(buf: ByteBuffer): ZcashAccountPubKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashAccountPubKey.read(buf)
    }

    override fun allocationSize(value: ZcashAccountPubKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashAccountPubKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashAccountPubKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashAccountPubKey.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashDiversifiableFullViewingKey: FfiConverterRustBuffer<ZcashDiversifiableFullViewingKey?> {
    override fun read(buf: ByteBuffer): ZcashDiversifiableFullViewingKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashDiversifiableFullViewingKey.read(buf)
    }

    override fun allocationSize(value: ZcashDiversifiableFullViewingKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashDiversifiableFullViewingKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashDiversifiableFullViewingKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashDiversifiableFullViewingKey.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashMemoBytes: FfiConverterRustBuffer<ZcashMemoBytes?> {
    override fun read(buf: ByteBuffer): ZcashMemoBytes? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashMemoBytes.read(buf)
    }

    override fun allocationSize(value: ZcashMemoBytes?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashMemoBytes.allocationSize(value)
        }
    }

    override fun write(value: ZcashMemoBytes?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashMemoBytes.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashOrchardAddress: FfiConverterRustBuffer<ZcashOrchardAddress?> {
    override fun read(buf: ByteBuffer): ZcashOrchardAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardAddress.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardAddress.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashOrchardBundle: FfiConverterRustBuffer<ZcashOrchardBundle?> {
    override fun read(buf: ByteBuffer): ZcashOrchardBundle? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardBundle.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardBundle?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardBundle.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardBundle?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardBundle.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashOrchardDiversifierIndex: FfiConverterRustBuffer<ZcashOrchardDiversifierIndex?> {
    override fun read(buf: ByteBuffer): ZcashOrchardDiversifierIndex? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardDiversifierIndex.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardDiversifierIndex?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardDiversifierIndex.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardDiversifierIndex?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardDiversifierIndex.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashOrchardFullViewingKey: FfiConverterRustBuffer<ZcashOrchardFullViewingKey?> {
    override fun read(buf: ByteBuffer): ZcashOrchardFullViewingKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardFullViewingKey.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardFullViewingKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardFullViewingKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardFullViewingKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardFullViewingKey.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashOrchardOutgoingViewingKey: FfiConverterRustBuffer<ZcashOrchardOutgoingViewingKey?> {
    override fun read(buf: ByteBuffer): ZcashOrchardOutgoingViewingKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardOutgoingViewingKey.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardOutgoingViewingKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardOutgoingViewingKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardOutgoingViewingKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashOutgoingViewingKey: FfiConverterRustBuffer<ZcashOutgoingViewingKey?> {
    override fun read(buf: ByteBuffer): ZcashOutgoingViewingKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOutgoingViewingKey.read(buf)
    }

    override fun allocationSize(value: ZcashOutgoingViewingKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOutgoingViewingKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashOutgoingViewingKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOutgoingViewingKey.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashPaymentAddress: FfiConverterRustBuffer<ZcashPaymentAddress?> {
    override fun read(buf: ByteBuffer): ZcashPaymentAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashPaymentAddress.read(buf)
    }

    override fun allocationSize(value: ZcashPaymentAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashPaymentAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashPaymentAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashPaymentAddress.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashSaplingBundle: FfiConverterRustBuffer<ZcashSaplingBundle?> {
    override fun read(buf: ByteBuffer): ZcashSaplingBundle? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashSaplingBundle.read(buf)
    }

    override fun allocationSize(value: ZcashSaplingBundle?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashSaplingBundle.allocationSize(value)
        }
    }

    override fun write(value: ZcashSaplingBundle?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashSaplingBundle.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashSaplingMerklePath: FfiConverterRustBuffer<ZcashSaplingMerklePath?> {
    override fun read(buf: ByteBuffer): ZcashSaplingMerklePath? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashSaplingMerklePath.read(buf)
    }

    override fun allocationSize(value: ZcashSaplingMerklePath?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashSaplingMerklePath.allocationSize(value)
        }
    }

    override fun write(value: ZcashSaplingMerklePath?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashSaplingMerklePath.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashTransparentAddress: FfiConverterRustBuffer<ZcashTransparentAddress?> {
    override fun read(buf: ByteBuffer): ZcashTransparentAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashTransparentAddress.read(buf)
    }

    override fun allocationSize(value: ZcashTransparentAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashTransparentAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashTransparentAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashTransparentAddress.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashTransparentBundle: FfiConverterRustBuffer<ZcashTransparentBundle?> {
    override fun read(buf: ByteBuffer): ZcashTransparentBundle? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashTransparentBundle.read(buf)
    }

    override fun allocationSize(value: ZcashTransparentBundle?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashTransparentBundle.allocationSize(value)
        }
    }

    override fun write(value: ZcashTransparentBundle?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashTransparentBundle.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashUnifiedAddress: FfiConverterRustBuffer<ZcashUnifiedAddress?> {
    override fun read(buf: ByteBuffer): ZcashUnifiedAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashUnifiedAddress.read(buf)
    }

    override fun allocationSize(value: ZcashUnifiedAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashUnifiedAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashUnifiedAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashUnifiedAddress.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashDiversifierIndexAndPaymentAddress: FfiConverterRustBuffer<ZcashDiversifierIndexAndPaymentAddress?> {
    override fun read(buf: ByteBuffer): ZcashDiversifierIndexAndPaymentAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.read(buf)
    }

    override fun allocationSize(value: ZcashDiversifierIndexAndPaymentAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashDiversifierIndexAndPaymentAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashDiversifierIndexAndScope: FfiConverterRustBuffer<ZcashDiversifierIndexAndScope?> {
    override fun read(buf: ByteBuffer): ZcashDiversifierIndexAndScope? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashDiversifierIndexAndScope.read(buf)
    }

    override fun allocationSize(value: ZcashDiversifierIndexAndScope?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashDiversifierIndexAndScope.allocationSize(value)
        }
    }

    override fun write(value: ZcashDiversifierIndexAndScope?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashDiversifierIndexAndScope.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashUnifiedAddressAndDiversifierIndex: FfiConverterRustBuffer<ZcashUnifiedAddressAndDiversifierIndex?> {
    override fun read(buf: ByteBuffer): ZcashUnifiedAddressAndDiversifierIndex? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.read(buf)
    }

    override fun allocationSize(value: ZcashUnifiedAddressAndDiversifierIndex?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.allocationSize(value)
        }
    }

    override fun write(value: ZcashUnifiedAddressAndDiversifierIndex?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeZcashOrchardScope: FfiConverterRustBuffer<ZcashOrchardScope?> {
    override fun read(buf: ByteBuffer): ZcashOrchardScope? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardScope.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardScope?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardScope.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardScope?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardScope.write(value, buf)
        }
    }
}




public object FfiConverterOptionalSequenceUByte: FfiConverterRustBuffer<List<UByte>?> {
    override fun read(buf: ByteBuffer): List<UByte>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceUByte.read(buf)
    }

    override fun allocationSize(value: List<UByte>?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterSequenceUByte.allocationSize(value)
        }
    }

    override fun write(value: List<UByte>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceUByte.write(value, buf)
        }
    }
}




public object FfiConverterSequenceUByte: FfiConverterRustBuffer<List<UByte>> {
    override fun read(buf: ByteBuffer): List<UByte> {
        val len = buf.getInt()
        return List<UByte>(len) {
            FfiConverterUByte.read(buf)
        }
    }

    override fun allocationSize(value: List<UByte>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterUByte.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UByte>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterUByte.write(it, buf)
        }
    }
}




public object FfiConverterSequenceUInt: FfiConverterRustBuffer<List<UInt>> {
    override fun read(buf: ByteBuffer): List<UInt> {
        val len = buf.getInt()
        return List<UInt>(len) {
            FfiConverterUInt.read(buf)
        }
    }

    override fun allocationSize(value: List<UInt>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterUInt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UInt>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterUInt.write(it, buf)
        }
    }
}




public object FfiConverterSequenceULong: FfiConverterRustBuffer<List<ULong>> {
    override fun read(buf: ByteBuffer): List<ULong> {
        val len = buf.getInt()
        return List<ULong>(len) {
            FfiConverterULong.read(buf)
        }
    }

    override fun allocationSize(value: List<ULong>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterULong.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ULong>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterULong.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashOrchardAction: FfiConverterRustBuffer<List<ZcashOrchardAction>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardAction> {
        val len = buf.getInt()
        return List<ZcashOrchardAction>(len) {
            FfiConverterTypeZcashOrchardAction.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardAction>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardAction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardAction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardAction.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashOrchardIncomingViewingKey: FfiConverterRustBuffer<List<ZcashOrchardIncomingViewingKey>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardIncomingViewingKey> {
        val len = buf.getInt()
        return List<ZcashOrchardIncomingViewingKey>(len) {
            FfiConverterTypeZcashOrchardIncomingViewingKey.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardIncomingViewingKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardIncomingViewingKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardIncomingViewingKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardIncomingViewingKey.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashOrchardMerkleHash: FfiConverterRustBuffer<List<ZcashOrchardMerkleHash>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardMerkleHash> {
        val len = buf.getInt()
        return List<ZcashOrchardMerkleHash>(len) {
            FfiConverterTypeZcashOrchardMerkleHash.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardMerkleHash>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardMerkleHash.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardMerkleHash>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardMerkleHash.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey: FfiConverterRustBuffer<List<ZcashOrchardOutgoingViewingKey>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardOutgoingViewingKey> {
        val len = buf.getInt()
        return List<ZcashOrchardOutgoingViewingKey>(len) {
            FfiConverterTypeZcashOrchardOutgoingViewingKey.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardOutgoingViewingKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardOutgoingViewingKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardOutgoingViewingKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardOutgoingViewingKey.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashOrchardSpendingKey: FfiConverterRustBuffer<List<ZcashOrchardSpendingKey>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardSpendingKey> {
        val len = buf.getInt()
        return List<ZcashOrchardSpendingKey>(len) {
            FfiConverterTypeZcashOrchardSpendingKey.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardSpendingKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardSpendingKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardSpendingKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardSpendingKey.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashSaplingOutputDescription: FfiConverterRustBuffer<List<ZcashSaplingOutputDescription>> {
    override fun read(buf: ByteBuffer): List<ZcashSaplingOutputDescription> {
        val len = buf.getInt()
        return List<ZcashSaplingOutputDescription>(len) {
            FfiConverterTypeZcashSaplingOutputDescription.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashSaplingOutputDescription>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashSaplingOutputDescription.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashSaplingOutputDescription>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashSaplingOutputDescription.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashSaplingSpendDescription: FfiConverterRustBuffer<List<ZcashSaplingSpendDescription>> {
    override fun read(buf: ByteBuffer): List<ZcashSaplingSpendDescription> {
        val len = buf.getInt()
        return List<ZcashSaplingSpendDescription>(len) {
            FfiConverterTypeZcashSaplingSpendDescription.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashSaplingSpendDescription>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashSaplingSpendDescription.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashSaplingSpendDescription>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashSaplingSpendDescription.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashTxIn: FfiConverterRustBuffer<List<ZcashTxIn>> {
    override fun read(buf: ByteBuffer): List<ZcashTxIn> {
        val len = buf.getInt()
        return List<ZcashTxIn>(len) {
            FfiConverterTypeZcashTxIn.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashTxIn>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashTxIn.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashTxIn>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashTxIn.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashTxOut: FfiConverterRustBuffer<List<ZcashTxOut>> {
    override fun read(buf: ByteBuffer): List<ZcashTxOut> {
        val len = buf.getInt()
        return List<ZcashTxOut>(len) {
            FfiConverterTypeZcashTxOut.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashTxOut>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashTxOut.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashTxOut>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashTxOut.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashAuthPath: FfiConverterRustBuffer<List<ZcashAuthPath>> {
    override fun read(buf: ByteBuffer): List<ZcashAuthPath> {
        val len = buf.getInt()
        return List<ZcashAuthPath>(len) {
            FfiConverterTypeZcashAuthPath.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashAuthPath>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashAuthPath.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashAuthPath>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashAuthPath.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys: FfiConverterRustBuffer<List<ZcashOrchardDecryptOutputForIncomingKeys>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardDecryptOutputForIncomingKeys> {
        val len = buf.getInt()
        return List<ZcashOrchardDecryptOutputForIncomingKeys>(len) {
            FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardDecryptOutputForIncomingKeys>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardDecryptOutputForIncomingKeys>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys: FfiConverterRustBuffer<List<ZcashOrchardDecryptOutputForOutgoingKeys>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardDecryptOutputForOutgoingKeys> {
        val len = buf.getInt()
        return List<ZcashOrchardDecryptOutputForOutgoingKeys>(len) {
            FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardDecryptOutputForOutgoingKeys>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardDecryptOutputForOutgoingKeys>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashPaymentParam: FfiConverterRustBuffer<List<ZcashPaymentParam>> {
    override fun read(buf: ByteBuffer): List<ZcashPaymentParam> {
        val len = buf.getInt()
        return List<ZcashPaymentParam>(len) {
            FfiConverterTypeZcashPaymentParam.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashPaymentParam>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashPaymentParam.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashPaymentParam>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashPaymentParam.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeZcashChildIndex: FfiConverterRustBuffer<List<ZcashChildIndex>> {
    override fun read(buf: ByteBuffer): List<ZcashChildIndex> {
        val len = buf.getInt()
        return List<ZcashChildIndex>(len) {
            FfiConverterTypeZcashChildIndex.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashChildIndex>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashChildIndex.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashChildIndex>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashChildIndex.write(it, buf)
        }
    }
}

@Throws(ZcashException::class)

    /**
     * Decodes an [`ExtendedFullViewingKey`] from a Bech32-encoded string. 
     */
fun `decodeExtendedFullViewingKey`(`hrp`: String, `s`: String): ZcashExtendedFullViewingKey {
    return FfiConverterTypeZcashExtendedFullViewingKey.lift(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_decode_extended_full_viewing_key(FfiConverterString.lower(`hrp`), FfiConverterString.lower(`s`), _status)
})
}



@Throws(ZcashException::class)

    /**
     * Decodes an [`ExtendedSpendingKey`] from a Bech32-encoded string. 
     */
fun `decodeExtendedSpendingKey`(`hrp`: String, `s`: String): ZcashExtendedSpendingKey {
    return FfiConverterTypeZcashExtendedSpendingKey.lift(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_decode_extended_spending_key(FfiConverterString.lower(`hrp`), FfiConverterString.lower(`s`), _status)
})
}



@Throws(ZcashException::class)

    /**
     * Decodes a [`PaymentAddress`] from a Bech32-encoded string. 
     */
fun `decodePaymentAddress`(`hrp`: String, `s`: String): ZcashPaymentAddress {
    return FfiConverterTypeZcashPaymentAddress.lift(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_decode_payment_address(FfiConverterString.lower(`hrp`), FfiConverterString.lower(`s`), _status)
})
}



@Throws(ZcashException::class)

    /**
     * Decodes a [`TransparentAddress`] from a Base58Check-encoded string. 
     */
fun `decodeTransparentAddress`(`pubkeyVersion`: List<UByte>, `scriptVersion`: List<UByte>, `s`: String): ZcashTransparentAddress {
    return FfiConverterTypeZcashTransparentAddress.lift(
    rustCallWithError(ZcashException) { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_decode_transparent_address(FfiConverterSequenceUByte.lower(`pubkeyVersion`), FfiConverterSequenceUByte.lower(`scriptVersion`), FfiConverterString.lower(`s`), _status)
})
}




    /**
     * Writes an [`ExtendedFullViewingKey`] as a Bech32-encoded string. 
     */
fun `encodeExtendedFullViewingKey`(`hrp`: String, `extfvk`: ZcashExtendedFullViewingKey): String {
    return FfiConverterString.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_encode_extended_full_viewing_key(FfiConverterString.lower(`hrp`), FfiConverterTypeZcashExtendedFullViewingKey.lower(`extfvk`), _status)
})
}




    /**
     * Writes an [`ExtendedSpendingKey`] as a Bech32-encoded string. 
     */
fun `encodeExtendedSpendingKey`(`hrp`: String, `extsk`: ZcashExtendedSpendingKey): String {
    return FfiConverterString.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_encode_extended_spending_key(FfiConverterString.lower(`hrp`), FfiConverterTypeZcashExtendedSpendingKey.lower(`extsk`), _status)
})
}




    /**
     * Decodes an [`ExtendedFullViewingKey`] from a Bech32-encoded string. 
     */
fun `encodePaymentAddress`(`hrp`: String, `addr`: ZcashPaymentAddress): String {
    return FfiConverterString.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_encode_payment_address(FfiConverterString.lower(`hrp`), FfiConverterTypeZcashPaymentAddress.lower(`addr`), _status)
})
}




    /**
     * Writes a [`PaymentAddress`] as a Bech32-encoded string 
     * using the human-readable prefix values defined in the specified 
     * network parameters. 
     */
fun `encodePaymentAddressP`(`params`: ZcashConsensusParameters, `addr`: ZcashPaymentAddress): String {
    return FfiConverterString.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_encode_payment_address_p(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterTypeZcashPaymentAddress.lower(`addr`), _status)
})
}




    /**
     * Writes a [`TransparentAddress`] as a Base58Check-encoded string. 
     */
fun `encodeTransparentAddress`(`pubkeyVersion`: List<UByte>, `scriptVersion`: List<UByte>, `addr`: ZcashTransparentAddress): String {
    return FfiConverterString.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_encode_transparent_address(FfiConverterSequenceUByte.lower(`pubkeyVersion`), FfiConverterSequenceUByte.lower(`scriptVersion`), FfiConverterTypeZcashTransparentAddress.lower(`addr`), _status)
})
}




    /**
     * Writes a [`TransparentAddress`] as a Base58Check-encoded string. 
     * using the human-readable prefix values defined in the specified 
     * network parameters. 
     */
fun `encodeTransparentAddressP`(`params`: ZcashConsensusParameters, `addr`: ZcashTransparentAddress): String {
    return FfiConverterString.lift(
    rustCall() { _status ->
    _UniFFILib.INSTANCE.zcash_6e86_encode_transparent_address_p(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterTypeZcashTransparentAddress.lower(`addr`), _status)
})
}




